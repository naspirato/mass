<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MASS - Metric Analytic Super System</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 30px 10px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 20px;
            margin-bottom: 4px;
            font-weight: 600;
            line-height: 1.2;
        }
        
        .header p {
            opacity: 0.85;
            font-size: 11px;
            margin-bottom: 0;
            line-height: 1.3;
        }
        
        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
            min-height: calc(100vh - 110px);
        }
        
        .form-section {
            padding: 30px;
            border-right: 1px solid #e0e0e0;
            overflow-y: auto;
            max-height: calc(100vh - 110px);
        }
        
        .preview-section {
            padding: 30px;
            background: #f8f9fa;
            overflow-y: auto;
            max-height: calc(100vh - 110px);
        }
        
        .section-title {
            font-size: 20px;
            font-weight: 600;
            color: #333;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            font-weight: 500;
            color: #555;
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        .label-help {
            font-size: 12px;
            color: #888;
            font-weight: normal;
            margin-top: 4px;
        }
        
        input[type="text"],
        input[type="number"],
        textarea,
        select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            font-family: 'Monaco', 'Courier New', monospace;
            transition: border-color 0.3s;
        }
        
        input:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        textarea {
            min-height: 100px;
            resize: vertical;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .detectors-grid {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .detector-item {
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 12px;
            background: #fafafa;
        }
        
        .detector-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }
        
        .detector-header label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
        }
        
        .detector-description {
            margin-top: 6px;
            font-size: 12px;
            color: #666;
        }
        
        .detector-params {
            margin-top: 10px;
            display: grid;
            gap: 10px;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        }
        
        .detector-params label {
            font-size: 12px;
            color: #555;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .detector-params input {
            padding: 6px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        
        .compare-detectors {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        input[type="checkbox"] {
            width: auto;
        }
        
        .array-input {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .array-input input {
            flex: 1;
        }
        
        .btn-remove {
            background: #f44336;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .btn-remove:hover {
            background: #d32f2f;
        }
        
        .btn-add {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 8px;
        }
        
        .btn-add:hover {
            background: #45a049;
        }
        
        .btn-generate {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            width: 100%;
            margin-top: 20px;
            transition: transform 0.2s;
        }
        
        .btn-generate:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .preview {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            white-space: pre-wrap;
            overflow-x: auto;
            max-height: calc(100vh - 300px);
            overflow-y: auto;
        }
        
        .btn-copy {
            background: #2196F3;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 15px;
            width: 100%;
        }
        
        .btn-copy:hover {
            background: #1976D2;
        }
        
        .collapsible {
            cursor: pointer;
            user-select: none;
        }
        
        .collapsible::before {
            content: '‚ñº ';
            display: inline-block;
            transition: transform 0.3s;
        }
        
        .collapsible.collapsed::before {
            transform: rotate(-90deg);
        }
        
        .collapsible-content {
            margin-top: 15px;
        }
        
        .collapsible-content.collapsed {
            display: none;
        }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 14px;
            font-weight: 500;
            color: #666;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
        }
        
        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .metric-direction-item {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .metric-param-item {
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 15px;
            background: #f9f9f9;
        }
        
        .metric-param-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .metric-param-name {
            font-weight: 600;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ MASS <span style="font-size: 14px; font-weight: 400;">(Metric Analytic Super System)</span></h1>
            <p>–ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–π –∏ –∑–∞–ø—É—Å–∫ –∞–Ω–∞–ª–∏—Ç–∏–∫–∏ –º–µ—Ç—Ä–∏–∫</p>
            
            <!-- Mode Switcher -->
            <div style="margin-top: 6px; display: flex; gap: 8px; justify-content: center; align-items: center; flex-wrap: wrap;">
                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; background: rgba(255,255,255,0.2); padding: 5px 12px; border-radius: 5px; font-size: 13px;">
                    <input type="radio" name="mode" value="generate" checked onchange="switchMode(this.value)" style="width: auto;">
                    <span>üÜï –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ –∫–æ–Ω—Ñ–∏–≥–∞</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; background: rgba(255,255,255,0.2); padding: 5px 12px; border-radius: 5px; font-size: 13px;">
                    <input type="radio" name="mode" value="edit" onchange="switchMode(this.value)" style="width: auto;">
                    <span>‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; background: rgba(255,255,255,0.2); padding: 5px 12px; border-radius: 5px; font-size: 13px;">
                    <input type="radio" name="mode" value="explore" onchange="switchMode(this.value)" style="width: auto;">
                    <span>üî¨ –ò—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ</span>
                </label>
            </div>
            
            <!-- File Loader (only in edit/explore mode) -->
            <div id="fileLoader" style="display: none; margin-top: 8px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 6px;">
                <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
                    <label style="display: inline-flex; align-items: center; gap: 6px; background: rgba(255,255,255,0.95); color: #333; padding: 6px 12px; border-radius: 5px; cursor: pointer; font-size: 13px; white-space: nowrap;" onmouseover="this.style.background='white';" onmouseout="this.style.background='rgba(255,255,255,0.95)';">
                        üìÅ –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª
                        <input type="file" id="yamlFileInput" accept=".yaml,.yml" style="display: none;" onchange="loadYamlFile(event)">
                    </label>
                    <span style="color: rgba(255,255,255,0.6); font-size: 12px;">–∏–ª–∏</span>
                    <select id="configsSelect" onchange="loadConfigFromSelect()" style="flex: 1; min-width: 200px; padding: 6px 10px; border-radius: 5px; border: 1px solid rgba(255,255,255,0.3); background: rgba(255,255,255,0.95); color: #333; font-size: 13px; cursor: pointer;">
                        <option value="">–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–Ω—Ñ–∏–≥ –∏–∑ configs/...</option>
                    </select>
                </div>
                <span id="fileName" style="display: block; margin-top: 6px; padding: 4px 8px; color: rgba(255,255,255,0.9); font-size: 12px; min-height: 16px;"></span>
            </div>
        </div>
        
        <div class="content">
            <div class="form-section">
                <form id="configForm">
                    <!-- Basic Info -->
                    <div class="section-title">üìã –û—Å–Ω–æ–≤–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è</div>
                    <div class="form-group">
                        <label>–ò–º—è –∑–∞–¥–∞—á–∏ (job.name) <span class="label-help">–£–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∏–º—è –¥–ª—è –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ –∑–∞–¥–∞—á–∏</span></label>
                        <input type="text" id="jobName" value="my_analysis" required>
                    </div>
                    <div class="form-group">
                        <label>–û–ø–∏—Å–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏ (job.description)</label>
                        <textarea id="jobDescription" placeholder="–û–ø–∏—Å–∞–Ω–∏–µ —Ç–æ–≥–æ, —á—Ç–æ –¥–µ–ª–∞–µ—Ç —ç—Ç–∞ –∑–∞–¥–∞—á–∞ –∞–Ω–∞–ª–∏—Ç–∏–∫–∏"></textarea>
                    </div>
                    
                    <!-- Data Source -->
                    <div class="section-title collapsible" onclick="toggleCollapse(this)">üìä –ò—Å—Ç–æ—á–Ω–∏–∫ –¥–∞–Ω–Ω—ã—Ö</div>
                    <div class="collapsible-content">
                        <div class="form-group">
                            <label>SQL-–∑–∞–ø—Ä–æ—Å (data_source.ydb.query) <span class="label-help">–ó–∞–ø—Ä–æ—Å –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –∏–∑ YDB</span></label>
                            <textarea id="ydbQuery" rows="8" placeholder='SELECT timestamp as ts, cluster, metric_value, &quot;metric_name&quot; FROM table WHERE ...' required></textarea>
                        </div>
                        <div class="form-group">
                            <label>–ê–≥—Ä–µ–≥–∞—Ü–∏—è –ø–æ –≤—Ä–µ–º–µ–Ω–∏ (data_source.aggregate_by) <span class="label-help">–û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: 1h, 15min, 1D –∏ —Ç.–¥.</span></label>
                            <input type="text" id="aggregateBy" placeholder="1h">
                        </div>
                    </div>
                    
                    <!-- Data Structure -->
                    <div class="section-title collapsible" onclick="toggleCollapse(this)">üîó –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö</div>
                    <div class="collapsible-content">
                        <div class="form-group">
                            <label>–ü–æ–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ (context_fields) <span class="label-help">–ü–æ–ª—è –¥–ª—è –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö</span></label>
                            <div id="contextFields">
                                <div class="array-input">
                                    <input type="text" placeholder="cluster" value="cluster">
                                    <button type="button" class="btn-remove" onclick="removeArrayItem(this)">√ó</button>
                                </div>
                            </div>
                            <button type="button" class="btn-add" onclick="addArrayItem('contextFields')">+ –î–æ–±–∞–≤–∏—Ç—å –ø–æ–ª–µ</button>
                        </div>
                        <div class="form-group">
                            <label>–ü–æ–ª—è –º–µ—Ç—Ä–∏–∫ (metric_fields) <span class="label-help">–û–±—ã—á–Ω–æ: ["metric_name", "metric_value"]</span></label>
                            <div id="metricFields">
                                <div class="array-input">
                                    <input type="text" value="metric_name" readonly>
                                    <button type="button" class="btn-remove" onclick="removeArrayItem(this)" disabled>√ó</button>
                                </div>
                                <div class="array-input">
                                    <input type="text" value="metric_value" readonly>
                                    <button type="button" class="btn-remove" onclick="removeArrayItem(this)" disabled>√ó</button>
                                </div>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>–ü–æ–ª–µ –≤—Ä–µ–º–µ–Ω–Ω–æ–π –º–µ—Ç–∫–∏ (timestamp_field)</label>
                            <input type="text" id="timestampField" value="ts" required>
                        </div>
                    </div>
                    
                    <!-- Analytics -->
                    <div class="section-title collapsible" onclick="toggleCollapse(this)">üìà –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–∏</div>
                    <div class="collapsible-content">
                        <div class="form-group">
                            <label>–ú–µ—Ç–æ–¥ baseline (analytics.baseline_method)</label>
                            <select id="baselineMethod">
                                <option value="rolling_mean" selected>rolling_mean - —Å–∫–æ–ª—å–∑—è—â–µ–µ —Å—Ä–µ–¥–Ω–µ–µ</option>
                                <option value="rolling_median">rolling_median - —Å–∫–æ–ª—å–∑—è—â–∞—è –º–µ–¥–∏–∞–Ω–∞</option>
                                <option value="zscore">zscore - —Å—Ç–∞—Ç–∏—Å—Ç–∏—á–µ—Å–∫–∏–π –º–µ—Ç–æ–¥</option>
                                <option value="prophet">prophet - Facebook Prophet</option>
                                <option value="adtk-levelshift">adtk-levelshift - ADTK</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>–†–∞–∑–º–µ—Ä –æ–∫–Ω–∞ (analytics.window_size) <span class="label-help">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ baseline</span></label>
                            <input type="number" id="windowSize" value="7" min="1" required>
                        </div>
                        <div class="form-group">
                            <label>–ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å (analytics.sensitivity) <span class="label-help">–ú–Ω–æ–∂–∏—Ç–µ–ª—å —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–≥–æ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è</span></label>
                            <input type="number" id="sensitivity" value="2.0" step="0.1" min="0.1" required>
                        </div>
                        <div class="form-group">
                            <label>–ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∞–±—Å–æ–ª—é—Ç–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ (analytics.min_absolute_change)</label>
                            <input type="number" id="minAbsoluteChange" value="5" min="0" required>
                        </div>
                        <div class="form-group">
                            <label>–ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ (analytics.min_relative_change) <span class="label-help">–û—Ç 0.0 –¥–æ 1.0 (–Ω–∞–ø—Ä–∏–º–µ—Ä, 0.05 = 5%)</span></label>
                            <input type="number" id="minRelativeChange" value="0.05" step="0.01" min="0" max="1" required>
                        </div>
                        <div class="form-group">
                            <label>–¢–æ—á–∫–∏ –≥–∏—Å—Ç–µ—Ä–µ–∑–∏—Å–∞ (analytics.hysteresis_points) <span class="label-help">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫ –ø–æ–¥—Ä—è–¥ –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —Å–æ–±—ã—Ç–∏—è</span></label>
                            <input type="number" id="hysteresisPoints" value="2" min="1" required>
                        </div>
                        <div class="form-group">
                            <label class="checkbox-group">
                                <input type="checkbox" id="adaptiveThreshold" checked>
                                –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –ø–æ—Ä–æ–≥–∏ (analytics.adaptive_threshold)
                            </label>
                        </div>
                        <div class="form-group">
                            <label>–ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫ (analytics.min_data_points)</label>
                            <input type="number" id="minDataPoints" value="3" min="1" required>
                        </div>
                    </div>
                    
                    <!-- Metric Direction -->
                    <div class="section-title collapsible" onclick="toggleCollapse(this)">‚ÜïÔ∏è –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–µ—Ç—Ä–∏–∫</div>
                    <div class="collapsible-content">
                        <div class="form-group">
                            <label>–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é (metric_direction.default)</label>
                            <select id="metricDirectionDefault">
                                <option value="negative">negative - –±–æ–ª—å—à–µ = —Ö—É–∂–µ (latency, errors)</option>
                                <option value="positive" selected>positive - –±–æ–ª—å—à–µ = –ª—É—á—à–µ (throughput, success)</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö –º–µ—Ç—Ä–∏–∫</label>
                            <div id="metricDirections"></div>
                            <button type="button" class="btn-add" onclick="addMetricDirection()">+ –î–æ–±–∞–≤–∏—Ç—å –º–µ—Ç—Ä–∏–∫—É</button>
                        </div>
                    </div>
                    
                    <!-- Context Tracking -->
                    <div class="section-title collapsible collapsed" onclick="toggleCollapse(this)">üîç –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)</div>
                    <div class="collapsible-content collapsed">
                        <div class="form-group">
                            <label class="checkbox-group">
                                <input type="checkbox" id="trackNewContexts">
                                –û—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å –Ω–æ–≤—ã–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç—ã (context_tracking.track_new_contexts)
                            </label>
                        </div>
                        <div class="form-group">
                            <label class="checkbox-group">
                                <input type="checkbox" id="trackDisappearedContexts">
                                –û—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å –∏—Å—á–µ–∑–Ω—É–≤—à–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç—ã (context_tracking.track_disappeared_contexts)
                            </label>
                        </div>
                        <div class="form-group">
                            <label>–ú–µ—Ç—Ä–∏–∫–∞ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –Ω–æ–≤—ã—Ö –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤</label>
                            <input type="text" id="newContextMetric" placeholder="error_count">
                        </div>
                        <div class="form-group">
                            <label>–¢–∏–ø —Å–æ–±—ã—Ç–∏—è –¥–ª—è –Ω–æ–≤—ã—Ö –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤</label>
                            <select id="newContextEventType">
                                <option value="degradation_start">degradation_start - –Ω–µ–≥–∞—Ç–∏–≤–Ω–æ–µ —Å–æ–±—ã—Ç–∏–µ</option>
                                <option value="improvement_start">improvement_start - –ø–æ–∑–∏—Ç–∏–≤–Ω–æ–µ —Å–æ–±—ã—Ç–∏–µ</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>–ú–µ—Ç—Ä–∏–∫–∞ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∏—Å—á–µ–∑–Ω—É–≤—à–∏—Ö –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤</label>
                            <input type="text" id="disappearedContextMetric" placeholder="error_count">
                        </div>
                        <div class="form-group">
                            <label>–ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è (min_absence_points)</label>
                            <input type="number" id="minAbsencePoints" value="3" min="1">
                        </div>
                    </div>
                    
                    <!-- Events -->
                    <div class="section-title collapsible" onclick="toggleCollapse(this)">‚ö° –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π</div>
                    <div class="collapsible-content">
                        <div class="form-group">
                            <label>–¢–∏–ø—ã —Å–æ–±—ã—Ç–∏–π –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è (events.detect)</label>
                            <div class="checkbox-group" style="flex-direction: column; align-items: flex-start; gap: 10px;">
                                <label class="checkbox-group">
                                    <input type="checkbox" id="detectDegradation" checked>
                                    degradation_start - –Ω–∞—á–∞–ª–æ –¥–µ–≥—Ä–∞–¥–∞—Ü–∏–∏
                                </label>
                                <label class="checkbox-group">
                                    <input type="checkbox" id="detectImprovement" checked>
                                    improvement_start - –Ω–∞—á–∞–ª–æ —É–ª—É—á—à–µ–Ω–∏—è
                                </label>
                                <label class="checkbox-group">
                                    <input type="checkbox" id="detectThresholdShift">
                                    threshold_shift - —Å–¥–≤–∏–≥ baseline
                                </label>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>–î–µ—Ç–µ–∫—Ç–æ—Ä—ã —Å–æ–±—ã—Ç–∏–π (events.detectors)</label>
                            <div id="detectorsContainer" class="detectors-grid"></div>
                        </div>
                        <div class="form-group">
                            <label>–î–µ—Ç–µ–∫—Ç–æ—Ä –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é (events.default_detector)</label>
                            <select id="defaultDetectorSelect" style="padding: 8px; border: 1px solid #ccc; border-radius: 4px;"></select>
                        </div>
                        <div class="form-group">
                            <label>–î–µ—Ç–µ–∫—Ç–æ—Ä—ã –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è (events.compare_detectors)</label>
                            <div id="compareDetectorsContainer" class="compare-detectors"></div>
                        </div>
                        <div class="form-group">
                            <label>–¢–∞–±–ª–∏—Ü–∞ –¥–ª—è —Å–æ–±—ã—Ç–∏–π (events.output_table) <span class="label-help">–û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ</span></label>
                            <input type="text" id="eventsOutputTable" placeholder="analytics/events">
                        </div>
                        <div class="form-group">
                            <label>–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Å–æ–±—ã—Ç–∏—è –≤ –º–∏–Ω—É—Ç–∞—Ö (events.min_event_duration_minutes)</label>
                            <input type="number" id="minEventDuration" value="30" min="0" required>
                        </div>
                    </div>
                    
                    <!-- Output -->
                    <div class="section-title collapsible" onclick="toggleCollapse(this)">üíæ –í—ã–≤–æ–¥ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤</div>
                    <div class="collapsible-content">
                        <div class="form-group">
                            <label>–¢–∞–±–ª–∏—Ü–∞ –¥–ª—è –ø–æ—Ä–æ–≥–æ–≤ (thresholds.output_table) <span class="label-help">–û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ</span></label>
                            <input type="text" id="thresholdsOutputTable" placeholder="analytics/thresholds">
                        </div>
                        <div class="form-group">
                            <label class="checkbox-group">
                                <input type="checkbox" id="keepHistory" checked>
                                –°–æ—Ö—Ä–∞–Ω—è—Ç—å –∏—Å—Ç–æ—Ä–∏—é –ø–æ—Ä–æ–≥–æ–≤ (thresholds.keep_history)
                            </label>
                        </div>
                        <div class="form-group">
                            <label class="checkbox-group">
                                <input type="checkbox" id="writeToYdb" checked>
                                –°–æ—Ö—Ä–∞–Ω—è—Ç—å –≤ YDB (output.write_to_ydb)
                            </label>
                        </div>
                        <div class="form-group">
                            <label class="checkbox-group">
                                <input type="checkbox" id="logToConsole" checked>
                                –õ–æ–≥–∏—Ä–æ–≤–∞—Ç—å –≤ –∫–æ–Ω—Å–æ–ª—å (output.log_to_console)
                            </label>
                        </div>
                        <div class="form-group">
                            <label class="checkbox-group">
                                <input type="checkbox" id="dryRun">
                                –†–µ–∂–∏–º dry-run (output.dry_run)
                            </label>
                        </div>
                    </div>
                    
                    <!-- Runtime -->
                    <div class="section-title collapsible collapsed" onclick="toggleCollapse(this)">‚è±Ô∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è</div>
                    <div class="collapsible-content collapsed">
                        <div class="form-group">
                            <label>–ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å (runtime.timezone)</label>
                            <input type="text" id="timezone" value="UTC">
                        </div>
                        <div class="form-group">
                            <label>–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –≤ –º–∏–Ω—É—Ç–∞—Ö (runtime.max_runtime_minutes)</label>
                            <input type="number" id="maxRuntime" value="15" min="1">
                        </div>
                    </div>
                    
                    <button type="button" class="btn-generate" onclick="generateConfig()">üöÄ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–æ–Ω—Ñ–∏–≥</button>
                    
                    <!-- Analytics Actions -->
                    <div style="margin-top: 20px; padding: 20px; background: #f0f0f0; border-radius: 8px;">
                        <h3 style="margin-bottom: 15px;">‚öôÔ∏è –î–µ–π—Å—Ç–≤–∏—è —Å –∫–æ–Ω—Ñ–∏–≥–æ–º</h3>
                        
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: 500;">–ò–º—è —Ñ–∞–π–ª–∞ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è:</label>
                            <input type="text" id="configFileName" placeholder="my_analysis.yaml" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        </div>
                        
                        <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                            <button type="button" class="btn-save" onclick="saveConfig()" style="flex: 1; padding: 10px; background: #4CAF50; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">
                                üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥
                            </button>
                            <button type="button" class="btn-run" onclick="runAnalytics()" style="flex: 1; padding: 10px; background: #2196F3; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">
                                ‚ñ∂Ô∏è –ó–∞–ø—É—Å—Ç–∏—Ç—å –∞–Ω–∞–ª–∏—Ç–∏–∫—É
                            </button>
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; font-weight: 500;">
                                –û–∫–Ω–æ –∞–Ω–∞–ª–∏–∑–∞ —Å–æ–±—ã—Ç–∏–π (event_deepness)
                                <span class="label-help">–ù–∞–ø—Ä–∏–º–µ—Ä: 7d, 30d, 12h, 2w</span>
                            </label>
                            <input type="text" id="eventDeepnessInput" placeholder="–Ω–∞–ø—Ä–∏–º–µ—Ä, 7d, 30d, 12h" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <label style="display: flex; align-items: center; gap: 8px;">
                                <input type="checkbox" id="dryRunCheck" checked>
                                <span>Dry run (–Ω–µ –∑–∞–ø–∏—Å—ã–≤–∞—Ç—å –≤ YDB)</span>
                            </label>
                        </div>
                        
                        <div id="runStatus" style="display: none; padding: 10px; border-radius: 6px; margin-top: 10px;"></div>
                    </div>
                    
                    <!-- Reports Section -->
                    <div style="margin-top: 20px; padding: 20px; background: #f0f0f0; border-radius: 8px;">
                        <h3 style="margin-bottom: 15px;">üìä –û—Ç—á–µ—Ç—ã</h3>
                        <button type="button" class="btn-refresh-reports" onclick="loadReports()" style="width: 100%; padding: 10px; background: #FF9800; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; margin-bottom: 15px;">
                            üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫ –æ—Ç—á–µ—Ç–æ–≤
                        </button>
                        <div id="reportsList" style="max-height: 300px; overflow-y: auto;">
                            <p style="color: #666; text-align: center; padding: 20px;">–ù–∞–∂–º–∏—Ç–µ "–û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫ –æ—Ç—á–µ—Ç–æ–≤" –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏</p>
                        </div>
                    </div>
                </form>
            </div>
            
            <div class="preview-section">
                <div class="section-title">üìÑ –ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –∫–æ–Ω—Ñ–∏–≥–∞</div>
                <div class="preview" id="preview">–ó–∞–ø–æ–ª–Ω–∏—Ç–µ —Ñ–æ—Ä–º—É –∏ –Ω–∞–∂–º–∏—Ç–µ "–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–æ–Ω—Ñ–∏–≥"</div>
                <button type="button" class="btn-copy" onclick="copyToClipboard()">üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞</button>
            </div>
            
            <!-- Explore Section (hidden by default) -->
            <div id="exploreSection" class="form-section" style="display: none; grid-column: 1 / -1;">
                <div class="section-title">üî¨ –†–µ–∂–∏–º –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è</div>
                <p style="color: #666; margin-bottom: 20px; line-height: 1.6;">
                    –í —ç—Ç–æ–º —Ä–µ–∂–∏–º–µ –≤—ã –º–æ–∂–µ—Ç–µ –∑–∞–ø—É—Å—Ç–∏—Ç—å –∞–Ω–∞–ª–∏—Ç–∏–∫—É —Å —Ä–∞–∑–Ω—ã–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏ –Ω–∞ –æ–¥–Ω–∏—Ö –∏ —Ç–µ—Ö –∂–µ –¥–∞–Ω–Ω—ã—Ö 
                    –∏ —Å—Ä–∞–≤–Ω–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã. –°–∏—Å—Ç–µ–º–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–∑–¥–∞—Å—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ —Å —Ä–∞–∑–Ω—ã–º–∏ 
                    –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–∏.
                </p>
                
                <div class="form-group">
                    <label>–ë–∞–∑–æ–≤—ã–π –∫–æ–Ω—Ñ–∏–≥ <span class="label-help">–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–Ω—Ñ–∏–≥, –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–æ—Ç–æ—Ä–æ–≥–æ –±—É–¥—É—Ç —Å–æ–∑–¥–∞–Ω—ã –≤–∞—Ä–∏–∞–Ω—Ç—ã</span></label>
                    <select id="exploreBaseConfig" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px;">
                        <option value="">–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–Ω—Ñ–∏–≥...</option>
                    </select>
                </div>
                
                <div class="form-group" style="margin-top: 20px; padding: 15px; background: #e7f3ff; border-radius: 6px; border-left: 4px solid #2196F3;">
                    <label style="font-weight: 600; color: #1976D2; margin-bottom: 10px; display: block;">üíæ –®–∞–≥ 1: –í—ã–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö</label>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 8px; font-size: 14px; color: #555;">–°–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ:</label>
                        <select id="savedDataSelect" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; margin-bottom: 10px;" onchange="onSavedDataSelected()">
                            <option value="">–í—ã–±–µ—Ä–∏—Ç–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–ª–∏ –∑–∞–≥—Ä—É–∑–∏—Ç–µ –Ω–æ–≤—ã–µ...</option>
                        </select>
                        <button type="button" class="btn-generate" onclick="loadSavedDataList()" style="width: 100%; margin-bottom: 10px; background: #9c27b0;">
                            üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫
                        </button>
                    </div>
                    
                    <div style="margin-bottom: 15px; padding-top: 15px; border-top: 1px solid #ddd;">
                        <button type="button" class="btn-generate" onclick="loadAndSaveData()" id="loadDataBtn" style="width: 100%;">
                            üì• –ó–∞–≥—Ä—É–∑–∏—Ç—å –Ω–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞
                        </button>
                    </div>
                    
                    <div id="dataStatus" style="display: none; padding: 10px; background: #d4edda; border-radius: 6px; margin-top: 10px;">
                        <span id="dataStatusText"></span>
                    </div>
                    <div style="margin-left: 0; margin-top: 8px; padding: 10px; background: #f8f9fa; border-radius: 6px; font-size: 13px; color: #666;">
                        –í—ã–±–µ—Ä–∏—Ç–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ —Å–ø–∏—Å–∫–∞ –∏–ª–∏ –∑–∞–≥—Ä—É–∑–∏—Ç–µ –Ω–æ–≤—ã–µ –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞. –ó–∞—Ç–µ–º –∑–∞–ø—É—Å—Ç–∏—Ç–µ –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ —Å —Ä–∞–∑–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏.
                    </div>
                </div>
                
                <div class="section-title" style="margin-top: 30px; font-size: 18px;">‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤</div>
                
                <div class="form-group" style="display: flex; gap: 16px; flex-wrap: wrap; align-items: center; margin-bottom: 15px;">
                    <label class="radio-group" style="margin: 0;">
                        <input type="radio" name="exploreMode" value="manual" checked>
                        <span>–†—É—á–Ω–æ–π –ø–æ–¥–±–æ—Ä –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤</span>
                    </label>
                    <label class="radio-group" style="margin: 0;">
                        <input type="radio" name="exploreMode" value="autodetectors">
                        <span>–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –∞–≤—Ç–æ–¥–µ—Ç–µ–∫—Ç–æ—Ä–æ–≤</span>
                    </label>
                </div>
                
                <div id="manualVariantControls">
                    <div class="form-group">
                        <label class="checkbox-group">
                            <input type="checkbox" id="varyBaselineMethod" checked>
                            <span>–í–∞—Ä—å–∏—Ä–æ–≤–∞—Ç—å –º–µ—Ç–æ–¥ baseline</span>
                        </label>
                        <div style="margin-left: 25px; margin-top: 8px; padding: 10px; background: #f8f9fa; border-radius: 6px; font-size: 13px; color: #666;">
                            –ë—É–¥–µ—Ç —Å–æ–∑–¥–∞–Ω–æ 3 –≤–∞—Ä–∏–∞–Ω—Ç–∞: rolling_mean, median, zscore
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label class="checkbox-group">
                            <input type="checkbox" id="varyWindowSize" checked>
                            <span>–í–∞—Ä—å–∏—Ä–æ–≤–∞—Ç—å —Ä–∞–∑–º–µ—Ä –æ–∫–Ω–∞ (window_size)</span>
                        </label>
                        <div style="margin-left: 25px; margin-top: 8px; padding: 10px; background: #f8f9fa; border-radius: 6px; font-size: 13px; color: #666;">
                            –ë—É–¥–µ—Ç —Å–æ–∑–¥–∞–Ω–æ 3 –≤–∞—Ä–∏–∞–Ω—Ç–∞: 7, 14, 30 —Ç–æ—á–µ–∫
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label class="checkbox-group">
                            <input type="checkbox" id="varySensitivity" checked>
                            <span>–í–∞—Ä—å–∏—Ä–æ–≤–∞—Ç—å —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å (sensitivity)</span>
                        </label>
                        <div style="margin-left: 25px; margin-top: 8px; padding: 10px; background: #f8f9fa; border-radius: 6px; font-size: 13px; color: #666;">
                            –ë—É–¥–µ—Ç —Å–æ–∑–¥–∞–Ω–æ 3 –≤–∞—Ä–∏–∞–Ω—Ç–∞: 1.5, 2.0, 2.5
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label class="checkbox-group">
                            <input type="checkbox" id="varyAdaptiveThreshold">
                            <span>–í–∞—Ä—å–∏—Ä–æ–≤–∞—Ç—å –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –ø–æ—Ä–æ–≥–∏ (adaptive_threshold)</span>
                        </label>
                        <div style="margin-left: 25px; margin-top: 8px; padding: 10px; background: #f8f9fa; border-radius: 6px; font-size: 13px; color: #666;">
                            –ë—É–¥–µ—Ç —Å–æ–∑–¥–∞–Ω–æ 2 –≤–∞—Ä–∏–∞–Ω—Ç–∞: true, false
                        </div>
                    </div>
                    
                    <div id="manualVariantInfo" style="margin-top: 20px; padding: 15px; background: #fff3cd; border-radius: 6px; border-left: 4px solid #ffc107;">
                        <strong>‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:</strong> –í—Å–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –±—É–¥—É—Ç –∑–∞–ø—É—â–µ–Ω—ã –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ. 
                        –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ = –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤. 
                        –ù–∞–ø—Ä–∏–º–µ—Ä, –µ—Å–ª–∏ –≤—ã–±—Ä–∞–Ω–æ 3 –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ —Å 3 –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏ –∫–∞–∂–¥—ã–π, –±—É–¥–µ—Ç —Å–æ–∑–¥–∞–Ω–æ –¥–æ 27 –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤.
                    </div>
                </div>
                
                <div class="form-group" id="detectorVariantControls" style="display: none;">
                    <div style="margin-bottom: 10px; font-weight: 500;">–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ –¥–µ—Ç–µ–∫—Ç–æ—Ä–æ–≤ –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è:</div>
                    <label class="checkbox-group">
                        <input type="checkbox" value="baseline_only" checked>
                        <span>Baseline Threshold</span>
                    </label>
                    <label class="checkbox-group">
                        <input type="checkbox" value="baseline_pyod">
                        <span>Baseline + PyOD Isolation Forest</span>
                    </label>
                    <label class="checkbox-group">
                        <input type="checkbox" value="baseline_ruptures">
                        <span>Baseline + Ruptures Change Point</span>
                    </label>
                    <div style="margin-left: 25px; margin-top: 8px; padding: 10px; background: #f8f9fa; border-radius: 6px; font-size: 13px; color: #666;">
                        –î–ª—è –∫–∞–∂–¥–æ–≥–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –Ω–∞–±–æ—Ä–∞ –±—É–¥–µ—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω –æ—Ç–¥–µ–ª—å–Ω—ã–π –ø—Ä–æ–≥–æ–Ω —Å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–º–∏ –∞–≤—Ç–æ–¥–µ—Ç–µ–∫—Ç–æ—Ä–∞–º–∏.
                    </div>
                    <div style="margin-top: 15px; padding: 12px; background: #e3f2fd; border-radius: 6px; border-left: 4px solid #2196F3;">
                        <strong>‚ÑπÔ∏è –°–æ–≤–µ—Ç:</strong> –í—ã –º–æ–∂–µ—Ç–µ —Ä–∞—Å—à–∏—Ä–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∫–æ–º–±–∏–Ω–∞—Ü–∏–π –∞–≤—Ç–æ–¥–µ—Ç–µ–∫—Ç–æ—Ä–æ–≤ –≤ –∫–æ–¥–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞.
                    </div>
                </div>
                
                <div id="variantModeInfo" style="margin-top: 20px; padding: 15px; background: #fff3cd; border-radius: 6px; border-left: 4px solid #ffc107;">
                    <strong>‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:</strong> –í —Ä–µ–∂–∏–º–µ –∞–≤—Ç–æ–¥–µ—Ç–µ–∫—Ç–æ—Ä–æ–≤ –∫–∞–∂–¥—ã–π –≤—ã–±—Ä–∞–Ω–Ω—ã–π –Ω–∞–±–æ—Ä –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω—ã–º –≤–∞—Ä–∏–∞–Ω—Ç–æ–º. –í —Ä—É—á–Ω–æ–º —Ä–µ–∂–∏–º–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ —Ä–∞–≤–Ω–æ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—é –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤.
                </div>
                
                <button type="button" class="btn-generate" onclick="runExploration()" id="runExplorationBtn" style="margin-top: 20px;" disabled>
                    üöÄ –®–∞–≥ 2: –ó–∞–ø—É—Å—Ç–∏—Ç—å –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ
                </button>
                
                <div id="exploreStatus" style="display: none; margin-top: 20px; padding: 15px; border-radius: 6px;"></div>
                
                <div id="exploreResults" style="margin-top: 30px; display: none;">
                    <div class="section-title">üìä –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å—Ä–∞–≤–Ω–µ–Ω–∏—è</div>
                    <div id="exploreResultsContent" style="margin-top: 20px;"></div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        let currentMode = 'generate';
        let explorationMode = 'manual';
        
        function updateExplorationModeUI() {
            const manualControls = document.getElementById('manualVariantControls');
            const detectorControls = document.getElementById('detectorVariantControls');
            const variantInfo = document.getElementById('variantModeInfo');
            
            if (manualControls) {
                manualControls.style.display = explorationMode === 'manual' ? '' : 'none';
            }
            if (detectorControls) {
                detectorControls.style.display = explorationMode === 'autodetectors' ? '' : 'none';
            }
            if (variantInfo) {
                if (explorationMode === 'manual') {
                    variantInfo.innerHTML = '<strong>‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:</strong> –í —Ä—É—á–Ω–æ–º —Ä–µ–∂–∏–º–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ = –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ (baseline, –æ–∫–Ω–æ, —á—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å, –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–π –ø–æ—Ä–æ–≥).';
                } else {
                    variantInfo.innerHTML = '<strong>‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:</strong> –í —Ä–µ–∂–∏–º–µ –∞–≤—Ç–æ–¥–µ—Ç–µ–∫—Ç–æ—Ä–æ–≤ –∫–∞–∂–¥—ã–π –≤—ã–±—Ä–∞–Ω–Ω—ã–π –Ω–∞–±–æ—Ä –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –∫–∞–∫ –æ—Ç–¥–µ–ª—å–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç. –ê–Ω–∞–ª–∏—Ç–∏—á–µ—Å–∫–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –±–µ—Ä—É—Ç—Å—è –∏–∑ –±–∞–∑–æ–≤–æ–≥–æ –∫–æ–Ω—Ñ–∏–≥–∞.';
                }
            }
        }
        
        function setupExplorationModeControls() {
            const modeInputs = document.querySelectorAll('input[name="exploreMode"]');
            modeInputs.forEach(input => {
                input.addEventListener('change', () => {
                    if (input.checked) {
                        explorationMode = input.value;
                        updateExplorationModeUI();
                    }
                });
            });
            updateExplorationModeUI();
        }
        
        function switchMode(mode) {
            currentMode = mode;
            const fileLoader = document.getElementById('fileLoader');
            const formSection = document.querySelector('.form-section');
            const previewSection = document.querySelector('.preview-section');
            
            if (mode === 'edit' || mode === 'explore') {
                fileLoader.style.display = 'block';
                // Load list of configs from configs/ directory
                loadConfigsList();
            } else {
                fileLoader.style.display = 'none';
                // Clear loaded file info
                document.getElementById('fileName').textContent = '';
                document.getElementById('yamlFileInput').value = '';
            }
            
            // Show/hide explore UI
            const exploreSection = document.getElementById('exploreSection');
            if (mode === 'explore') {
                if (exploreSection) {
                    exploreSection.style.display = 'block';
                }
                if (formSection) formSection.style.display = 'none';
                if (previewSection) previewSection.style.display = 'none';
                setupExplorationModeControls();
                // Load saved data list when entering explore mode
                loadSavedDataList();
            } else {
                if (exploreSection) {
                    exploreSection.style.display = 'none';
                }
                if (formSection) formSection.style.display = 'block';
                if (previewSection) previewSection.style.display = 'block';
            }
        }
        
        function loadConfigsList() {
            // Load list of available configs from API
            fetch('/api/configs')
                .then(response => response.json())
                .then(data => {
                    const select = document.getElementById('configsSelect');
                    const exploreSelect = document.getElementById('exploreBaseConfig');
                    
                    // Clear existing options except the first one
                    const defaultOption = '<option value="">–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–Ω—Ñ–∏–≥ –∏–∑ configs/...</option>';
                    if (select) {
                        select.innerHTML = defaultOption;
                    }
                    if (exploreSelect) {
                        exploreSelect.innerHTML = '<option value="">–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–Ω—Ñ–∏–≥...</option>';
                    }
                    
                    // Add configs to both selects
                    if (data.configs && data.configs.length > 0) {
                        data.configs.forEach(config => {
                            const option = document.createElement('option');
                            option.value = config.path;
                            option.textContent = config.name;
                            if (select) select.appendChild(option.cloneNode(true));
                            if (exploreSelect) exploreSelect.appendChild(option);
                        });
                    } else {
                        const option = document.createElement('option');
                        option.value = '';
                        option.textContent = '–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–æ–Ω—Ñ–∏–≥–æ–≤';
                        option.disabled = true;
                        if (select) select.appendChild(option.cloneNode(true));
                        if (exploreSelect) exploreSelect.appendChild(option);
                    }
                })
                .catch(error => {
                    console.error('Error loading configs list:', error);
                    const select = document.getElementById('configsSelect');
                    const exploreSelect = document.getElementById('exploreBaseConfig');
                    if (select) select.innerHTML = '<option value="">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–ø–∏—Å–∫–∞</option>';
                    if (exploreSelect) exploreSelect.innerHTML = '<option value="">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–ø–∏—Å–∫–∞</option>';
                });
        }
        
        let savedDataFile = null;
        
        async function loadSavedDataList() {
            const select = document.getElementById('savedDataSelect');
            const loadBtn = document.getElementById('loadDataBtn');
            
            if (!select) return;
            
            try {
                const response = await fetch('/api/saved-data');
                const data = await response.json();
                
                // Clear existing options except the first one
                select.innerHTML = '<option value="">–í—ã–±–µ—Ä–∏—Ç–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–ª–∏ –∑–∞–≥—Ä—É–∑–∏—Ç–µ –Ω–æ–≤—ã–µ...</option>';
                
                if (data.success && data.files && data.files.length > 0) {
                    data.files.forEach(file => {
                        const option = document.createElement('option');
                        option.value = file.path;
                        const fileSize = (file.size / 1024 / 1024).toFixed(2); // MB
                        const modifiedDate = new Date(file.modified).toLocaleString('ru-RU');
                        option.textContent = `${file.name} (${fileSize} MB, ${modifiedDate})`;
                        select.appendChild(option);
                    });
                } else {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = '–ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö';
                    option.disabled = true;
                    select.appendChild(option);
                }
            } catch (error) {
                console.error('Error loading saved data list:', error);
                select.innerHTML = '<option value="">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–ø–∏—Å–∫–∞</option>';
            }
        }
        
        function onSavedDataSelected() {
            const select = document.getElementById('savedDataSelect');
            const runBtn = document.getElementById('runExplorationBtn');
            const statusDiv = document.getElementById('dataStatus');
            const statusText = document.getElementById('dataStatusText');
            
            if (select && select.value) {
                savedDataFile = select.value;
                runBtn.disabled = false;
                
                if (statusDiv && statusText) {
                    statusDiv.style.display = 'block';
                    statusDiv.style.background = '#d4edda';
                    statusDiv.style.color = '#155724';
                    statusText.textContent = `‚úÖ –í—ã–±—Ä–∞–Ω—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ: ${select.options[select.selectedIndex].textContent.split(' (')[0]}`;
                }
            } else {
                if (!savedDataFile) {
                    runBtn.disabled = true;
                }
            }
        }
        
        async function loadAndSaveData() {
            const baseConfigPath = document.getElementById('exploreBaseConfig').value;
            const statusDiv = document.getElementById('dataStatus');
            const loadBtn = document.getElementById('loadDataBtn');
            const runBtn = document.getElementById('runExplorationBtn');
            
            if (!baseConfigPath) {
                alert('–í—ã–±–µ—Ä–∏—Ç–µ –±–∞–∑–æ–≤—ã–π –∫–æ–Ω—Ñ–∏–≥');
                return;
            }
            
            loadBtn.disabled = true;
            loadBtn.textContent = '‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö...';
            statusDiv.style.display = 'block';
            statusDiv.style.background = '#fff3cd';
            statusDiv.style.color = '#856404';
            const statusText = document.getElementById('dataStatusText');
            if (statusText) {
                statusText.textContent = '‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞...';
            } else {
                statusDiv.innerHTML = '‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –∏–∑ –∏—Å—Ç–æ—á–Ω–∏–∫–∞...';
            }
            
            try {
                const response = await fetch('/api/load-data', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({base_config_path: baseConfigPath})
                });
                
                const data = await response.json();
                
                if (data.success) {
                    savedDataFile = data.data_file;
                    statusDiv.style.background = '#d4edda';
                    statusDiv.style.color = '#155724';
                    if (statusText) {
                        statusText.textContent = `‚úÖ –î–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã: ${data.data_file}`;
                    } else {
                        statusDiv.innerHTML = `‚úÖ –î–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã: ${data.data_file}`;
                    }
                    runBtn.disabled = false;
                    // Reload saved data list to include the new file
                    await loadSavedDataList();
                    // Select the newly saved file
                    const select = document.getElementById('savedDataSelect');
                    if (select) {
                        select.value = data.data_file;
                        onSavedDataSelected();
                    }
                } else {
                    statusDiv.style.background = '#f8d7da';
                    statusDiv.style.color = '#721c24';
                    if (statusText) {
                        statusText.textContent = `‚ùå –û—à–∏–±–∫–∞: ${data.error}`;
                    } else {
                        statusDiv.innerHTML = `‚ùå –û—à–∏–±–∫–∞: ${data.error}`;
                    }
                }
            } catch (error) {
                statusDiv.style.background = '#f8d7da';
                statusDiv.style.color = '#721c24';
                if (statusText) {
                    statusText.textContent = `‚ùå –û—à–∏–±–∫–∞: ${error.message}`;
                } else {
                    statusDiv.innerHTML = `‚ùå –û—à–∏–±–∫–∞: ${error.message}`;
                }
            } finally {
                loadBtn.disabled = false;
                loadBtn.textContent = 'üíæ –®–∞–≥ 1: –ó–∞–≥—Ä—É–∑–∏—Ç—å –∏ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –¥–∞–Ω–Ω—ã–µ';
            }
        }
        
        async function runExploration() {
            const baseConfigPath = document.getElementById('exploreBaseConfig').value;
            const statusDiv = document.getElementById('exploreStatus');
            const resultsDiv = document.getElementById('exploreResults');
            const resultsContent = document.getElementById('exploreResultsContent');
            const eventDeepnessInput = document.getElementById('eventDeepnessInput');
            const eventDeepness = eventDeepnessInput ? eventDeepnessInput.value.trim() : '';
            
            if (!baseConfigPath) {
                alert('–í—ã–±–µ—Ä–∏—Ç–µ –±–∞–∑–æ–≤—ã–π –∫–æ–Ω—Ñ–∏–≥');
                return;
            }
            
            if (!savedDataFile) {
                alert('–°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ (–®–∞–≥ 1)');
                return;
            }
            
            const mode = explorationMode || 'manual';
            
            // Collect variant settings
            const variants = { mode };
            if (mode === 'manual') {
                variants.vary_baseline_method = document.getElementById('varyBaselineMethod').checked;
                variants.vary_window_size = document.getElementById('varyWindowSize').checked;
                variants.vary_sensitivity = document.getElementById('varySensitivity').checked;
                variants.vary_adaptive_threshold = document.getElementById('varyAdaptiveThreshold').checked;
                
                const manualFlags = [
                    variants.vary_baseline_method,
                    variants.vary_window_size,
                    variants.vary_sensitivity,
                    variants.vary_adaptive_threshold
                ];
                
                if (!manualFlags.some(Boolean)) {
                    alert('–í—ã–±–µ—Ä–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä –¥–ª—è –≤–∞—Ä—å–∏—Ä–æ–≤–∞–Ω–∏—è');
                    return;
                }
            } else {
                const detectorChecks = Array.from(document.querySelectorAll('#detectorVariantControls input[type="checkbox"]:checked'));
                const detectorVariants = detectorChecks.map(cb => cb.value);
                if (detectorVariants.length === 0) {
                    alert('–í—ã–±–µ—Ä–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –Ω–∞–±–æ—Ä –∞–≤—Ç–æ–¥–µ—Ç–µ–∫—Ç–æ—Ä–æ–≤ –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è');
                    return;
                }
                variants.detector_variants = detectorVariants;
            }
            
            // Show status
            statusDiv.style.display = 'block';
            statusDiv.style.background = '#fff3cd';
            statusDiv.style.color = '#856404';
            statusDiv.innerHTML = '‚è≥ –ó–∞–ø—É—Å–∫ –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è... –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è.';
            resultsDiv.style.display = 'none';
            
            try {
                // Use AbortController for timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 3600000); // 1 hour timeout
                
                  const bodyPayload = {
                      base_config_path: baseConfigPath,
                      variants: variants,
                      data_file: savedDataFile
                  };
                  if (eventDeepness) {
                      bodyPayload.event_deepness = eventDeepness;
                  }
                  
                  const response = await fetch('/api/explore', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                      body: JSON.stringify(bodyPayload),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                // Check if response is JSON
                const contentType = response.headers.get('content-type');
                let data;
                
                if (contentType && contentType.includes('application/json')) {
                    data = await response.json();
                } else {
                    // If not JSON, try to get text for error message
                    const text = await response.text();
                    throw new Error(`Server returned non-JSON response (${response.status}): ${text.substring(0, 200)}`);
                }
                
                if (response.ok && data.success) {
                    statusDiv.style.background = '#d4edda';
                    statusDiv.style.color = '#155724';
                    statusDiv.innerHTML = `<strong>‚úÖ –ò—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!</strong><br>–û–±—Ä–∞–±–æ—Ç–∞–Ω–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤: ${data.results ? data.results.length : 0}`;
                    
                    // Display results
                    if (data.results) {
                        displayExplorationResults(data.results);
                        resultsDiv.style.display = 'block';
                    }
                } else {
                    statusDiv.style.background = '#f8d7da';
                    statusDiv.style.color = '#721c24';
                    const errorMsg = data.error || data.message || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞';
                    statusDiv.innerHTML = `<strong>‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è</strong><br><pre style="margin-top: 10px; font-size: 12px; overflow-x: auto; white-space: pre-wrap;">${errorMsg}</pre>`;
                }
            } catch (error) {
                statusDiv.style.background = '#f8d7da';
                statusDiv.style.color = '#721c24';
                let errorMsg = error.message || String(error);
                if (error.name === 'AbortError') {
                    errorMsg = '–ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –æ—Ç–≤–µ—Ç–∞ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞. –ò—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏ —Å–µ—Ä–≤–µ—Ä–∞.';
                } else if (error.message && error.message.includes('Failed to fetch')) {
                    errorMsg = '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É. –í–æ–∑–º–æ–∂–Ω–æ, —Å–µ—Ä–≤–µ—Ä –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω –∏–ª–∏ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏ —Å–µ—Ä–≤–µ—Ä–∞.';
                }
                statusDiv.innerHTML = `<strong>‚ùå –û—à–∏–±–∫–∞:</strong><br><pre style="margin-top: 10px; font-size: 12px; overflow-x: auto; white-space: pre-wrap;">${errorMsg}</pre>`;
                console.error('Exploration error:', error);
            }
        }
        
        function displayExplorationResults(results) {
            const resultsContent = document.getElementById('exploreResultsContent');
            
            if (!results || results.length === 0) {
                resultsContent.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">–ù–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è</p>';
                return;
            }
            
            const isAutodetectorMode = results.some(result => {
                const variant = result.variant || {};
                return variant.mode === 'autodetectors' || variant.detector_variant || result.detector_variant;
            });
            
            let html = '<div style="overflow-x: auto;">';
            html += '<table style="width: 100%; border-collapse: collapse; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">';
            html += '<thead><tr style="background: #667eea; color: white;">';
            html += '<th style="padding: 12px; text-align: left; border-bottom: 2px solid #5568d3;">–í–∞—Ä–∏–∞–Ω—Ç</th>';
            if (isAutodetectorMode) {
                html += '<th style="padding: 12px; text-align: left;">–ù–∞–±–æ—Ä –¥–µ—Ç–µ–∫—Ç–æ—Ä–æ–≤</th>';
            } else {
                html += '<th style="padding: 12px; text-align: left;">–ú–µ—Ç–æ–¥</th>';
                html += '<th style="padding: 12px; text-align: left;">–û–∫–Ω–æ</th>';
                html += '<th style="padding: 12px; text-align: left;">–ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å</th>';
                html += '<th style="padding: 12px; text-align: left;">–ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π</th>';
            }
            html += '<th style="padding: 12px; text-align: center;">–°–æ–±—ã—Ç–∏–π</th>';
            html += '<th style="padding: 12px; text-align: center;">–ë–µ–π–∑–ª–∞–π–Ω–æ–≤</th>';
            html += '<th style="padding: 12px; text-align: center;">–î–µ–π—Å—Ç–≤–∏—è</th>';
            html += '</tr></thead><tbody>';
            
            results.forEach((result, index) => {
                const variant = result.variant || {};
                const eventsCount = result.events_count || 0;
                const baselinesCount = result.baselines_count || 0;
                const reportPath = result.report_path || '';
                
                html += '<tr style="border-bottom: 1px solid #e0e0e0;">';
                html += `<td style="padding: 12px; font-weight: 500;">–í–∞—Ä–∏–∞–Ω—Ç ${index + 1}</td>`;
                
                if (isAutodetectorMode) {
                    const detectorLabel = variant.detector_label || variant.detector_variant || `–ù–∞–±–æ—Ä ${index + 1}`;
                    const detectorDetails = Array.isArray(variant.detectors_list)
                        ? variant.detectors_list.join(', ')
                        : (variant.detectors_description || detectorLabel);
                    html += `<td style="padding: 12px;">${detectorLabel}<div style="color: #666; font-size: 12px; margin-top: 4px;">${detectorDetails}</div></td>`;
                } else {
                    html += `<td style="padding: 12px;">${variant.baseline_method || '-'}</td>`;
                    html += `<td style="padding: 12px;">${variant.window_size || '-'}</td>`;
                    html += `<td style="padding: 12px;">${variant.sensitivity || '-'}</td>`;
                    html += `<td style="padding: 12px;">${variant.adaptive_threshold ? '–î–∞' : '–ù–µ—Ç'}</td>`;
                }
                
                html += `<td style="padding: 12px; text-align: center;"><strong>${eventsCount}</strong></td>`;
                html += `<td style="padding: 12px; text-align: center;">${baselinesCount}</td>`;
                html += '<td style="padding: 12px; text-align: center; vertical-align: top;">';
                if (reportPath) {
                    html += `<a href="${reportPath}" target="_blank" style="padding: 8px 16px; background: #2196F3; color: white; text-decoration: none; border-radius: 4px; font-size: 13px; font-weight: 500; display: inline-block;">üìÑ –û—Ç–∫—Ä—ã—Ç—å –æ—Ç—á–µ—Ç</a>`;
                } else {
                    html += '<span style="color: #999; font-size: 12px;">–ù–µ—Ç –æ—Ç—á–µ—Ç–∞</span>';
                }
                if (eventsCount === 0 && result.recommendations && result.recommendations.length > 0) {
                    html += `<div style="margin-top: 8px; padding: 8px; background: #fff3cd; border-radius: 4px; font-size: 11px; text-align: left; max-width: 300px;">`;
                    result.recommendations.forEach(rec => {
                        html += `<div style="margin-bottom: 3px;">üí° ${rec}</div>`;
                    });
                    html += `</div>`;
                }
                html += '</td>';
                html += '</tr>';
            });
            
            html += '</tbody></table></div>';
            
            // Add summary statistics
            html += '<div style="margin-top: 30px; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">';
            
            const totalEvents = results.reduce((sum, r) => sum + (r.events_count || 0), 0);
            const totalBaselines = results.reduce((sum, r) => sum + (r.baselines_count || 0), 0);
            const avgEvents = (totalEvents / results.length).toFixed(1);
            const maxEvents = Math.max(...results.map(r => r.events_count || 0));
            const minEvents = Math.min(...results.map(r => r.events_count || 0));
            
            html += '<div style="padding: 15px; background: #e3f2fd; border-radius: 8px; border-left: 4px solid #2196F3;">';
            html += '<div style="font-size: 24px; font-weight: bold; color: #1976d2;">' + results.length + '</div>';
            html += '<div style="color: #666; font-size: 14px;">–í—Å–µ–≥–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤</div>';
            html += '</div>';
            
            html += '<div style="padding: 15px; background: #fff3e0; border-radius: 8px; border-left: 4px solid #ff9800;">';
            html += '<div style="font-size: 24px; font-weight: bold; color: #f57c00;">' + totalEvents + '</div>';
            html += '<div style="color: #666; font-size: 14px;">–í—Å–µ–≥–æ —Å–æ–±—ã—Ç–∏–π</div>';
            html += '</div>';
            
            html += '<div style="padding: 15px; background: #f3e5f5; border-radius: 8px; border-left: 4px solid #9c27b0;">';
            html += '<div style="font-size: 24px; font-weight: bold; color: #7b1fa2;">' + avgEvents + '</div>';
            html += '<div style="color: #666; font-size: 14px;">–°—Ä–µ–¥–Ω–µ–µ —Å–æ–±—ã—Ç–∏–π/–≤–∞—Ä–∏–∞–Ω—Ç</div>';
            html += '</div>';
            
            html += '<div style="padding: 15px; background: #e8f5e9; border-radius: 8px; border-left: 4px solid #4caf50;">';
            html += '<div style="font-size: 24px; font-weight: bold; color: #388e3c;">' + minEvents + ' - ' + maxEvents + '</div>';
            html += '<div style="color: #666; font-size: 14px;">–î–∏–∞–ø–∞–∑–æ–Ω —Å–æ–±—ã—Ç–∏–π</div>';
            html += '</div>';
            
            html += '</div>';
            
            // Add summary reports section (instead of full gallery)
            html += generateSummaryReportsSection(results);
            
            resultsContent.innerHTML = html;
        }

        // Ensure exploration mode UI is initialized on load
        setupExplorationModeControls();
        
        function generateSummaryReportsSection(results) {
            // Extract contexts from results (from first variant that has contexts_info)
            let allContexts = [];
            for (const result of results) {
                if (result.contexts_info && result.contexts_info.length > 0) {
                    allContexts = result.contexts_info;
                    break;
                }
            }
            
            let html = '<div style="margin-top: 40px; padding: 20px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">';
            html += '<h3 style="margin: 0 0 20px 0; color: #333; font-size: 18px;">üìÑ Summary –æ—Ç—á–µ—Ç—ã</h3>';
            html += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 15px; margin-bottom: 30px;">';
            
            results.forEach((result, index) => {
                const variant = result.variant || {};
                const reportPath = result.report_path || '';
                const eventsCount = result.events_count || 0;
                const baselinesCount = result.baselines_count || 0;
                const isAutodetectorVariant = variant.mode === 'autodetectors';
                const detectorLabel = variant.detector_label || variant.detector_variant;
                const detectorDetails = Array.isArray(variant.detectors_list)
                    ? variant.detectors_list.join(', ')
                    : (variant.detectors_description || detectorLabel || '');
                
                html += '<div style="border: 1px solid #e0e0e0; border-radius: 8px; padding: 15px; background: #f9f9f9; transition: transform 0.2s, box-shadow 0.2s;" ';
                html += 'onmouseover="this.style.transform=\'translateY(-2px)\'; this.style.boxShadow=\'0 4px 8px rgba(0,0,0,0.1)\';" ';
                html += 'onmouseout="this.style.transform=\'translateY(0)\'; this.style.boxShadow=\'none\';"';
                html += '>';
                
                html += `<div style="font-weight: 600; color: #333; margin-bottom: 8px; font-size: 16px;">–í–∞—Ä–∏–∞–Ω—Ç ${index + 1}</div>`;
                html += '<div style="font-size: 12px; color: #666; margin-bottom: 10px;">';
                if (isAutodetectorVariant) {
                    html += detectorLabel || '–ù–∞–±–æ—Ä –∞–≤—Ç–æ–¥–µ—Ç–µ–∫—Ç–æ—Ä–æ–≤';
                    if (detectorDetails && detectorDetails !== detectorLabel) {
                        html += `<div style="margin-top: 4px;">${detectorDetails}</div>`;
                    }
                } else {
                    html += `${variant.baseline_method || 'N/A'} | –æ–∫–Ω–æ: ${variant.window_size || 'N/A'}`;
                }
                html += '</div>';
                
                html += '<div style="display: flex; gap: 10px; margin-bottom: 10px; font-size: 12px;">';
                html += `<span style="padding: 4px 8px; background: #ffebee; color: #c62828; border-radius: 4px;">${eventsCount} —Å–æ–±—ã—Ç–∏–π</span>`;
                html += `<span style="padding: 4px 8px; background: #e8f5e9; color: #2e7d32; border-radius: 4px;">${baselinesCount} –±–µ–π–∑–ª–∞–π–Ω–æ–≤</span>`;
                html += `</div>`;
                
                if (reportPath) {
                    html += `<a href="${reportPath}" target="_blank" style="display: block; padding: 8px 12px; background: #2196F3; color: white; text-decoration: none; border-radius: 4px; font-size: 13px; text-align: center; font-weight: 500;">üìÑ –û—Ç–∫—Ä—ã—Ç—å –æ—Ç—á–µ—Ç</a>`;
                } else {
                    html += '<div style="padding: 8px 12px; background: #e0e0e0; color: #999; border-radius: 4px; font-size: 13px; text-align: center;">–ù–µ—Ç –æ—Ç—á–µ—Ç–∞</div>';
                }
                
                html += '</div>';
            });
            
            html += '</div>';
            
            // Add context selector and graphs section
            if (allContexts.length > 0) {
                html += '<div style="margin-top: 30px; padding-top: 30px; border-top: 2px solid #e0e0e0;">';
                html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; flex-wrap: wrap; gap: 15px;">';
                html += '<h3 style="margin: 0; color: #333; font-size: 18px;">üìä –ì—Ä–∞—Ñ–∏–∫–∏ –ø–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞–º</h3>';
                html += '<div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">';
                html += '<label style="color: #666; font-size: 14px;">–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç:</label>';
                html += '<select id="contextFilter" onchange="filterVisualizationsByContext(this.value)" style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; background: white; cursor: pointer; min-width: 400px;">';
                html += '<option value="">-- –í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –≥—Ä–∞—Ñ–∏–∫–æ–≤ --</option>';
                allContexts.forEach((ctx) => {
                    const eventsText = ctx.events_count > 0 ? `, ${ctx.events_count} —Å–æ–±—ã—Ç–∏–π` : '';
                    html += `<option value="${ctx.context_hash}">${ctx.context_display} (${ctx.viz_count} —Ç–æ—á–µ–∫${eventsText})</option>`;
                });
                html += '</select>';
                html += '</div>';
                html += '</div>';
                
                // Container for graphs (will be populated when context is selected)
                html += '<div id="contextGraphsContainer" style="display: none; margin-top: 20px;">';
                html += '</div>';
                
                html += '</div>';
            }
            
            html += '</div>';
            
            // Store results and contexts globally for later use
            window.explorationResults = results;
            window.explorationContexts = allContexts;
            
            return html;
        }
        
        function pluralizeRu(count, one, few, many) {
            const n = Math.abs(count) % 100;
            const n1 = n % 10;
            if (n > 10 && n < 20) return many;
            if (n1 > 1 && n1 < 5) return few;
            if (n1 === 1) return one;
            return many;
        }

        function summarizeDetectorResults(detectorResults) {
            if (!Array.isArray(detectorResults)) {
                return [];
            }
            return detectorResults.map(det => {
                const events = Array.isArray(det.events) ? det.events : [];
                let positive = 0;
                let negative = 0;
                events.forEach(evt => {
                    const eventType = String(evt?.event_type || '').toLowerCase();
                    if (eventType.includes('improvement')) {
                        positive += 1;
                    } else if (eventType.includes('degradation')) {
                        negative += 1;
                    }
                });
                return {
                    id: det.detector_id || det.detector_label || 'detector',
                    label: det.detector_label || det.detector_id || '–î–µ—Ç–µ–∫—Ç–æ—Ä',
                    type: det.detector_type || '',
                    total: events.length,
                    positive,
                    negative
                };
            });
        }

        function renderDetectorSummaryList(detectorSummaries, options = {}) {
            if (!Array.isArray(detectorSummaries) || detectorSummaries.length === 0) {
                return '';
            }

            const {
                heading = '–î–µ—Ç–µ–∫—Ç–æ—Ä—ã',
                wrapperStyle = 'margin-top: 8px; font-size: 11px; color: #444;',
                showType = false
            } = options;

            const sorted = detectorSummaries
                .map(det => ({
                    ...det,
                    total: det?.total ?? 0,
                    positive: det?.positive ?? 0,
                    negative: det?.negative ?? 0,
                    label: det?.label || det?.id || '–î–µ—Ç–µ–∫—Ç–æ—Ä',
                    type: det?.type || ''
                }))
                .sort((a, b) => b.total - a.total);

            let html = `<div style="${wrapperStyle}">`;
            html += `<div style="font-weight: 600; margin-bottom: 4px;">${heading}</div>`;

            sorted.forEach(det => {
                const totalText = `${det.total} ${pluralizeRu(det.total, '—Å–æ–±—ã—Ç–∏–µ', '—Å–æ–±—ã—Ç–∏—è', '—Å–æ–±—ã—Ç–∏–π')}`;
                const details = [];
                if (det.positive > 0) {
                    details.push(`üü¢ ${det.positive}`);
                }
                if (det.negative > 0) {
                    details.push(`üî¥ ${det.negative}`);
                }
                const detailsText = details.length ? ` (${details.join(', ')})` : '';
                const labelText = showType && det.type ? `${det.label} ¬∑ ${det.type}` : det.label;
                html += `<div style="display: flex; justify-content: space-between; gap: 12px; margin-bottom: 2px;">`;
                html += `<span>${labelText}</span>`;
                html += `<span>${totalText}${detailsText}</span>`;
                html += `</div>`;
            });

            html += '</div>';
            return html;
        }

        function generateVisualizationGallery(results) {
            // Extract contexts from results (from first variant that has contexts_info)
            let allContexts = [];
            for (const result of results) {
                if (result.contexts_info && result.contexts_info.length > 0) {
                    allContexts = result.contexts_info;
                    break;
                }
            }
            
            // Build mapping: context_hash -> {metric -> {variant_index: [viz_files]}}
            const contextsMap = new Map();
            
            results.forEach((result, variantIndex) => {
                const vizFiles = result.visualization_files || [];
                vizFiles.forEach(vizItem => {
                    // Handle both new format (object with path, metric_name, events_count) and old format (string path)
                    const vizPath = typeof vizItem === 'string' ? vizItem : vizItem.path;
                    const metricName = typeof vizItem === 'object' && vizItem.metric_name ? vizItem.metric_name : 'unknown';
                    const metricEventsCount = typeof vizItem === 'object' && vizItem.events_count !== undefined ? vizItem.events_count : 0;
                    const metricPositiveEvents = typeof vizItem === 'object' && vizItem.positive_events_count !== undefined ? vizItem.positive_events_count : 0;
                    const metricNegativeEvents = typeof vizItem === 'object' && vizItem.negative_events_count !== undefined ? vizItem.negative_events_count : 0;
                    const detectorResults = typeof vizItem === 'object' && Array.isArray(vizItem.detector_results) ? vizItem.detector_results : [];
                    
                    // Extract context hash from filename
                    const filename = vizPath.split('/').pop();
                    const parts = filename.replace('.html', '').split('_');
                    
                    let contextHashShort = '';
                    const eventIndex = parts.indexOf('event');
                    if (eventIndex >= 0 && eventIndex + 1 < parts.length) {
                        contextHashShort = parts[eventIndex + 1]; // 8-char hash
                    }
                    
                    // Find full context_hash from contexts_info
                    let fullContextHash = contextHashShort;
                    let contextDisplay = `Context ${contextHashShort}`;
                    for (const ctx of allContexts) {
                        if (ctx.context_hash_short === contextHashShort) {
                            fullContextHash = ctx.context_hash;
                            contextDisplay = ctx.context_display || contextDisplay;
                            break;
                        }
                    }
                    
                    if (!contextsMap.has(fullContextHash)) {
                        contextsMap.set(fullContextHash, {
                            context_hash: fullContextHash,
                            context_hash_short: contextHashShort,
                            context_display: contextDisplay,
                            metrics: new Map()
                        });
                    }
                    
                    const contextData = contextsMap.get(fullContextHash);
                    // Group by metric name - each metric has its own visualization file
                    const metricKey = metricName;
                    if (!contextData.metrics.has(metricKey)) {
                        contextData.metrics.set(metricKey, {});
                    }
                    // Only store one file per variant, context, and metric
                    if (!contextData.metrics.get(metricKey)[variantIndex]) {
                        contextData.metrics.get(metricKey)[variantIndex] = [{
                              path: vizPath,
                              variantIndex,
                              variant: result.variant || {},
                              metricName,
                              eventsCount: metricEventsCount,
                              positiveEventsCount: metricPositiveEvents,
                              negativeEventsCount: metricNegativeEvents,
                              detectorResults
                          }];
                      }
                });
            });
            
            if (contextsMap.size === 0) {
                return '<div style="margin-top: 30px; padding: 20px; background: #f5f5f5; border-radius: 8px; text-align: center; color: #666;">üìä –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã</div>';
            }
            
            // Convert to array and sort by number of visualizations (data points) descending
            const contextsArray = Array.from(contextsMap.values()).map(ctx => {
                let totalVizCount = 0;
                ctx.metrics.forEach((variants) => {
                    Object.values(variants).forEach(vizList => {
                        totalVizCount += vizList.length;
                    });
                });
                return {
                    ...ctx,
                    viz_count: totalVizCount
                };
            });
            contextsArray.sort((a, b) => b.viz_count - a.viz_count);
            
            let html = '<div style="margin-top: 40px; padding: 20px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">';
            html += '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; flex-wrap: wrap; gap: 15px;">';
            html += '<h3 style="margin: 0; color: #333; font-size: 18px;">üìä –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞–º</h3>';
            html += '<div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">';
            html += '<label style="color: #666; font-size: 14px;">–ö–æ–Ω—Ç–µ–∫—Å—Ç:</label>';
            html += '<select id="contextFilter" onchange="filterVisualizationsByContext(this.value)" style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; background: white; cursor: pointer; min-width: 300px;">';
            html += '<option value="all">–í—Å–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç—ã</option>';
            contextsArray.forEach((ctx, idx) => {
                const eventsText = ctx.events_count > 0 ? `, ${ctx.events_count} —Å–æ–±—ã—Ç–∏–π` : '';
                html += `<option value="${ctx.context_hash}">${ctx.context_display} (${ctx.viz_count} —Ç–æ—á–µ–∫${eventsText})</option>`;
            });
            html += '</select>';
            html += '</div>';
            html += '</div>';
            
            // Generate gallery for each context
            contextsArray.forEach((ctx, ctxIndex) => {
                html += `<div class="context-gallery" data-context="${ctx.context_hash}" style="display: ${ctxIndex === 0 ? 'block' : 'none'}; margin-bottom: 30px;">`;
                html += `<h4 style="margin: 0 0 15px 0; color: #667eea; font-size: 16px;">${ctx.context_display} <span style="color: #999; font-size: 14px; font-weight: normal;">(${ctx.viz_count} —Ç–æ—á–µ–∫ –¥–∞–Ω–Ω—ã—Ö)</span></h4>`;
                
                // Now each context has one visualization file (not per metric)
                // Show visualizations for each variant
                
                    const contextInfo = allContexts.find(info => info.context_hash === ctx.context_hash);
                    if (contextInfo && Array.isArray(contextInfo.detectors) && contextInfo.detectors.length > 0) {
                        const aggregatedSummary = contextInfo.detectors.map(det => ({
                            id: det.id,
                            label: det.label,
                            total: det.events_count || 0,
                            positive: det.positive_events_count || 0,
                            negative: det.negative_events_count || 0
                        }));
                        const aggregatedHtml = renderDetectorSummaryList(aggregatedSummary, {
                            heading: '–°–≤–æ–¥–∫–∞ –¥–µ—Ç–µ–∫—Ç–æ—Ä–æ–≤',
                            wrapperStyle: 'margin: 10px 0 18px 0; padding: 10px; background: #f4f6ff; border-radius: 6px; font-size: 11px; color: #2f3c8f;',
                            showType: false
                        });
                        if (aggregatedHtml) {
                            html += aggregatedHtml;
                        }
                    }
                    
                // Group by metrics first, then show variants for each metric
                ctx.metrics.forEach((metricVizMap, metricName) => {
                    // Get all variants for this metric
                    const allVariantsForMetric = [];
                    results.forEach((result, variantIndex) => {
                        const variantViz = metricVizMap[variantIndex] || [];
                        if (variantViz.length > 0) {
                            allVariantsForMetric.push({ variantIndex, viz: variantViz[0], result });
                        }
                    });
                    
                    if (allVariantsForMetric.length > 0) {
                        // Get events count for this metric (from first variant, they should be the same for all variants)
                        const firstViz = allVariantsForMetric[0].viz;
                        const metricEventsCount = firstViz.eventsCount || 0;
                        const metricPositiveEvents = firstViz.positiveEventsCount || 0;
                        const metricNegativeEvents = firstViz.negativeEventsCount || 0;
                        const displayMetricName = firstViz.metricName && firstViz.metricName !== 'all_metrics' ? firstViz.metricName : metricName;
                        
                        // Metric header (without event counts - they are shown per variant)
                        html += `<div style="margin-bottom: 30px;">`;
                        html += `<h4 style="margin: 0 0 15px 0; color: #667eea; font-size: 18px; font-weight: 600;">${displayMetricName}</h4>`;
                        
                        // Grid for variants of this metric
                        html += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px;">';
                        
                        // Show all variants for this metric
                        allVariantsForMetric.forEach(({ variantIndex, viz, result }) => {
                            const variant = viz.variant || {};
                            const variantLabel = `–í–∞—Ä–∏–∞–Ω—Ç ${variantIndex + 1}`;
                            const isAutodetectorVariant = variant.mode === 'autodetectors';
                            let variantInfoHtml;
                            if (isAutodetectorVariant) {
                                const detectorLabel = variant.detector_label || variant.detector_variant || '–ù–∞–±–æ—Ä –∞–≤—Ç–æ–¥–µ—Ç–µ–∫—Ç–æ—Ä–æ–≤';
                                const detectorDetails = Array.isArray(variant.detectors_list)
                                    ? variant.detectors_list.join(', ')
                                    : (variant.detectors_description || detectorLabel);
                                variantInfoHtml = `${detectorLabel}`;
                                if (detectorDetails && detectorDetails !== detectorLabel) {
                                    variantInfoHtml += `<div style="margin-top: 2px; color: #888;">${detectorDetails}</div>`;
                                }
                            } else {
                                variantInfoHtml = `${variant.baseline_method || 'N/A'} | –æ–∫–Ω–æ: ${variant.window_size || 'N/A'} | —á—É–≤—Å—Ç–≤: ${variant.sensitivity || 'N/A'}`;
                            }
                            // Use metric-specific events count
                            const positiveEvents = viz.positiveEventsCount || 0;
                            const negativeEvents = viz.negativeEventsCount || 0;
                            const eventsCount = viz.eventsCount || 0;
                                
                                html += '<div class="viz-thumbnail" style="border: 1px solid #e0e0e0; border-radius: 8px; overflow: hidden; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: transform 0.2s, box-shadow 0.2s;" ';
                                html += 'onmouseover="this.style.transform=\'scale(1.02)\'; this.style.boxShadow=\'0 4px 8px rgba(0,0,0,0.15)\';" ';
                                html += 'onmouseout="this.style.transform=\'scale(1)\'; this.style.boxShadow=\'0 2px 4px rgba(0,0,0,0.1)\';" ';
                                html += 'onclick="openVisualization(\'' + viz.path + '\', \'' + variantLabel + '\')" ';
                                html += 'style="cursor: pointer;" data-viz-path="' + viz.path + '">';
                                
                                // Thumbnail preview - use lazy loading
                                html += `<div style="position: relative; width: 100%; height: 400px; overflow: hidden; background: #f5f5f5; display: flex; align-items: center; justify-content: center;">`;
                                html += `<div class="viz-placeholder" style="color: #999; font-size: 14px;">–ó–∞–≥—Ä—É–∑–∫–∞ –≥—Ä–∞—Ñ–∏–∫–∞...</div>`;
                                html += `<iframe class="viz-iframe" data-src="${viz.path}" style="display: none; width: 100%; height: 100%; border: none; pointer-events: none;"></iframe>`;
                                html += `<div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(255,255,255,0.01); cursor: pointer;"></div>`;
                                html += `</div>`;
                                
                                // Variant info
                                html += '<div style="padding: 12px; background: #f9f9f9;">';
                                html += `<div style="font-weight: 600; color: #333; margin-bottom: 4px;">${variantLabel}</div>`;
                                html += `<div style="font-size: 12px; color: #666;">${variantInfoHtml}</div>`;
                                
                                // Events info with positive/negative split
                                if (eventsCount > 0) {
                                    const positiveText = positiveEvents > 0 ? `${positiveEvents} ${positiveEvents === 1 ? '–ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ' : positiveEvents < 5 ? '–ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã—Ö' : '–ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã—Ö'}` : '';
                                    const negativeText = negativeEvents > 0 ? `${negativeEvents} ${negativeEvents === 1 ? '–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ' : negativeEvents < 5 ? '–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã—Ö' : '–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã—Ö'}` : '';
                                    let eventsText = '';
                                    if (positiveText && negativeText) {
                                        eventsText = `üü¢ ${positiveText}, üî¥ ${negativeText}`;
                                    } else if (positiveText) {
                                        eventsText = `üü¢ ${positiveText}`;
                                    } else if (negativeText) {
                                        eventsText = `üî¥ ${negativeText}`;
                                    } else {
                                        eventsText = `‚ö™ ${eventsCount} ${eventsCount === 1 ? '—Å–æ–±—ã—Ç–∏–µ' : eventsCount < 5 ? '—Å–æ–±—ã—Ç–∏—è' : '—Å–æ–±—ã—Ç–∏–π'}`;
                                    }
                                    html += `<div style="margin-top: 6px; font-size: 12px; font-weight: 500; color: #333;">${eventsText}</div>`;
                                } else {
                                    html += `<div style="margin-top: 6px; font-size: 12px; font-weight: 500; color: #666;">‚ö™ –ù–µ—Ç —Å–æ–±—ã—Ç–∏–π</div>`;
                                }
                                const detectorSummaryHtml = renderDetectorSummaryList(
                                    summarizeDetectorResults(viz.detectorResults || []),
                                    { wrapperStyle: 'margin-top: 8px; font-size: 11px; color: #444;' }
                                );
                                if (detectorSummaryHtml) {
                                    html += detectorSummaryHtml;
                                }
                                html += `<div style="margin-top: 8px; display: flex; gap: 8px; flex-wrap: wrap;">`;
                                html += `<a href="${viz.path}" target="_blank" onclick="event.stopPropagation();" style="padding: 4px 8px; background: #2196F3; color: white; text-decoration: none; border-radius: 4px; font-size: 11px;">üîó –û—Ç–∫—Ä—ã—Ç—å</a>`;
                                html += `<span style="padding: 4px 8px; background: #e0e0e0; color: #666; border-radius: 4px; font-size: 11px; cursor: pointer;" onclick="event.stopPropagation(); expandThumbnail(this)">üîç –£–≤–µ–ª–∏—á–∏—Ç—å</span>`;
                                // Add "Save Data" button
                                const dataFilename = viz.path.split('/').pop().replace('.html', '_data.json');
                                html += `<a href="/api/viz-data/${dataFilename}" onclick="event.stopPropagation();" download="${dataFilename}" style="padding: 4px 8px; background: #4CAF50; color: white; text-decoration: none; border-radius: 4px; font-size: 11px;">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –¥–∞–Ω–Ω—ã–µ</a>`;
                                html += `</div>`;
                            html += `</div>`;
                            html += `</div>`;
                        });
                        
                        html += '</div>'; // Close grid for this metric
                        html += '</div>'; // Close metric section
                    }
                });
                
                html += '</div>';
            });
            
            html += '</div>';
            
            // Initialize lazy loading for iframes after HTML is inserted
            setTimeout(() => {
                initializeLazyLoading();
            }, 100);
            
            return html;
        }
        
        function initializeLazyLoading() {
            // Use Intersection Observer for lazy loading iframes
            if ('IntersectionObserver' in window) {
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const iframe = entry.target;
                            const container = iframe.parentElement;
                            const placeholder = container ? container.querySelector('.viz-placeholder') : null;
                            
                            if (iframe.dataset.src && !iframe.src) {
                                iframe.src = iframe.dataset.src;
                                iframe.onload = function() {
                                    iframe.style.opacity = '1';
                                    if (placeholder) {
                                        placeholder.style.display = 'none';
                                    }
                                };
                                observer.unobserve(iframe);
                            }
                        }
                    });
                }, {
                    rootMargin: '100px' // Start loading 100px before visible
                });
                
                document.querySelectorAll('.viz-iframe').forEach(iframe => {
                    observer.observe(iframe);
                });
            } else {
                // Fallback: load all iframes immediately if IntersectionObserver is not supported
                document.querySelectorAll('.viz-iframe').forEach(iframe => {
                    if (iframe.dataset.src) {
                        iframe.src = iframe.dataset.src;
                        const container = iframe.parentElement;
                        const placeholder = container ? container.querySelector('.viz-placeholder') : null;
                        iframe.onload = function() {
                            iframe.style.opacity = '1';
                            if (placeholder) {
                                placeholder.style.display = 'none';
                            }
                        };
                    }
                });
            }
        }
        
        function showAllGraphsForContext(contextHash) {
            // This would require re-rendering with all graphs
            // For now, just show a message
            alert('–§—É–Ω–∫—Ü–∏—è "–ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ" –±—É–¥–µ—Ç —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–∞ –≤ —Å–ª–µ–¥—É—é—â–µ–π –≤–µ—Ä—Å–∏–∏. –ü–æ–∫–∞ —á—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–∏–ª—å—Ç—Ä –ø–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞–º –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö –≥—Ä–∞—Ñ–∏–∫–æ–≤.');
        }
        
        function filterVisualizationsByContext(contextHash) {
            const container = document.getElementById('contextGraphsContainer');
            if (!container) return;
            
            if (!contextHash || contextHash === '') {
                container.style.display = 'none';
                container.innerHTML = '';
                return;
            }
            
            // Find selected context
            const selectedContext = window.explorationContexts.find(ctx => ctx.context_hash === contextHash);
            if (!selectedContext) return;
            
            // Build mapping: context_hash -> {metric -> {variant_index: [viz_files]}}
            const contextsMap = new Map();
            
            window.explorationResults.forEach((result, variantIndex) => {
                const vizFiles = result.visualization_files || [];
                vizFiles.forEach(vizItem => {
                    // Handle both new format (object with path, metric_name, events_count) and old format (string path)
                    const vizPath = typeof vizItem === 'string' ? vizItem : vizItem.path;
                    const metricName = typeof vizItem === 'object' && vizItem.metric_name ? vizItem.metric_name : 'unknown';
                    const metricEventsCount = typeof vizItem === 'object' && vizItem.events_count !== undefined ? vizItem.events_count : 0;
                    const metricPositiveEvents = typeof vizItem === 'object' && vizItem.positive_events_count !== undefined ? vizItem.positive_events_count : 0;
                    const metricNegativeEvents = typeof vizItem === 'object' && vizItem.negative_events_count !== undefined ? vizItem.negative_events_count : 0;
                    const detectorResults = typeof vizItem === 'object' && Array.isArray(vizItem.detector_results) ? vizItem.detector_results : [];

                    // Extract context hash from filename
                    const filename = vizPath.split('/').pop();
                    const parts = filename.replace('.html', '').split('_');
                    
                    let contextHashShort = '';
                    const eventIndex = parts.indexOf('event');
                    if (eventIndex >= 0 && eventIndex + 1 < parts.length) {
                        contextHashShort = parts[eventIndex + 1]; // 8-char hash
                    }
                    
                    // Check if this file belongs to selected context
                    if (contextHashShort === selectedContext.context_hash_short) {
                        if (!contextsMap.has(selectedContext.context_hash)) {
                            contextsMap.set(selectedContext.context_hash, {
                                context_hash: selectedContext.context_hash,
                                context_display: selectedContext.context_display,
                                metrics: new Map()
                            });
                        }
                        
                        const contextData = contextsMap.get(selectedContext.context_hash);
                        // Group by metric name - each metric has its own visualization file
                        const metricKey = metricName;
                        if (!contextData.metrics.has(metricKey)) {
                            contextData.metrics.set(metricKey, {});
                        }
                        // Only store one file per variant, context, and metric
                        if (!contextData.metrics.get(metricKey)[variantIndex]) {
                            contextData.metrics.get(metricKey)[variantIndex] = [{
                                path: vizPath,
                                variantIndex,
                                variant: result.variant || {},
                                metricName,
                                eventsCount: metricEventsCount,
                                positiveEventsCount: metricPositiveEvents,
                                negativeEventsCount: metricNegativeEvents,
                                detectorResults
                            }];
                        }
                    }
                });
            });
            
            // Generate HTML for selected context graphs
            let graphsHtml = '';
            const contextData = contextsMap.get(contextHash);
            if (contextData) {
                graphsHtml += `<h4 style="margin: 0 0 15px 0; color: #667eea; font-size: 16px;">${contextData.context_display}</h4>`;

                const aggregatedSummary = (selectedContext.detectors || []).map(det => ({
                    id: det.id,
                    label: det.label,
                    total: det.events_count || 0,
                    positive: det.positive_events_count || 0,
                    negative: det.negative_events_count || 0
                }));
                const aggregatedHtml = renderDetectorSummaryList(aggregatedSummary, {
                    heading: '–°–≤–æ–¥–∫–∞ –¥–µ—Ç–µ–∫—Ç–æ—Ä–æ–≤ –ø–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É',
                    wrapperStyle: 'margin: 10px 0 20px 0; padding: 12px; background: #eef2ff; border-radius: 6px; font-size: 12px; color: #25316d;',
                    showType: false
                });
                if (aggregatedHtml) {
                    graphsHtml += aggregatedHtml;
                }
                
                // Group by metrics first, then show variants for each metric
                contextData.metrics.forEach((metricVizMap, metricName) => {
                    // Get all variants for this metric
                    const allVariantsForMetric = [];
                    window.explorationResults.forEach((result, variantIndex) => {
                        const variantViz = metricVizMap[variantIndex] || [];
                        if (variantViz.length > 0) {
                            allVariantsForMetric.push({ variantIndex, viz: variantViz[0], result });
                        }
                    });
                    
                    if (allVariantsForMetric.length > 0) {
                        // Get events count for this metric (from first variant, they should be the same for all variants)
                        const firstViz = allVariantsForMetric[0].viz;
                        const metricEventsCount = firstViz.eventsCount || 0;
                        const metricPositiveEvents = firstViz.positiveEventsCount || 0;
                        const metricNegativeEvents = firstViz.negativeEventsCount || 0;
                        const displayMetricName = firstViz.metricName && firstViz.metricName !== 'all_metrics' ? firstViz.metricName : metricName;
                        
                        // Metric header (without event counts - they are shown per variant)
                        graphsHtml += `<div style="margin-bottom: 30px;">`;
                        graphsHtml += `<h4 style="margin: 0 0 15px 0; color: #667eea; font-size: 18px; font-weight: 600;">${displayMetricName}</h4>`;
                        
                        // Grid for variants of this metric
                        graphsHtml += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px;">';
                        
                        // Show all variants for this metric
                        allVariantsForMetric.forEach(({ variantIndex, viz, result }) => {
                            const variant = viz.variant || {};
                            const variantLabel = `–í–∞—Ä–∏–∞–Ω—Ç ${variantIndex + 1}`;
                            const isAutodetectorVariant = variant.mode === 'autodetectors';
                            let variantInfoHtml;
                            if (isAutodetectorVariant) {
                                const detectorLabel = variant.detector_label || variant.detector_variant || '–ù–∞–±–æ—Ä –∞–≤—Ç–æ–¥–µ—Ç–µ–∫—Ç–æ—Ä–æ–≤';
                                const detectorDetails = Array.isArray(variant.detectors_list)
                                    ? variant.detectors_list.join(', ')
                                    : (variant.detectors_description || detectorLabel);
                                variantInfoHtml = `${detectorLabel}`;
                                if (detectorDetails && detectorDetails !== detectorLabel) {
                                    variantInfoHtml += `<div style="margin-top: 2px; color: #888;">${detectorDetails}</div>`;
                                }
                            } else {
                                variantInfoHtml = `${variant.baseline_method || 'N/A'} | –æ–∫–Ω–æ: ${variant.window_size || 'N/A'} | —á—É–≤—Å—Ç–≤: ${variant.sensitivity || 'N/A'}`;
                            }
                            // Use metric-specific events count
                            const positiveEvents = viz.positiveEventsCount || 0;
                            const negativeEvents = viz.negativeEventsCount || 0;
                            const eventsCount = viz.eventsCount || 0;
                            
                            graphsHtml += '<div class="viz-thumbnail" style="border: 1px solid #e0e0e0; border-radius: 8px; overflow: hidden; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); transition: transform 0.2s, box-shadow 0.2s;" ';
                            graphsHtml += 'onmouseover="this.style.transform=\'scale(1.02)\'; this.style.boxShadow=\'0 4px 8px rgba(0,0,0,0.15)\';" ';
                            graphsHtml += 'onmouseout="this.style.transform=\'scale(1)\'; this.style.boxShadow=\'0 2px 4px rgba(0,0,0,0.1)\';" ';
                            graphsHtml += 'onclick="openVisualization(\'' + viz.path + '\', \'' + variantLabel + '\')" ';
                            graphsHtml += 'style="cursor: pointer;" data-viz-path="' + viz.path + '">';
                            
                            graphsHtml += `<div style="position: relative; width: 100%; height: 400px; overflow: hidden; background: #f5f5f5;">`;
                            graphsHtml += `<div class="viz-placeholder" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; color: #999; font-size: 14px; background: #f5f5f5; z-index: 1;">–ó–∞–≥—Ä—É–∑–∫–∞ –≥—Ä–∞—Ñ–∏–∫–∞...</div>`;
                            graphsHtml += `<iframe class="viz-iframe" data-src="${viz.path}" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; pointer-events: none; opacity: 0; z-index: 0;"></iframe>`;
                            graphsHtml += `<div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(255,255,255,0.01); cursor: pointer; z-index: 2;"></div>`;
                            graphsHtml += `</div>`;
                            
                            graphsHtml += '<div style="padding: 12px; background: #f9f9f9;">';
                            graphsHtml += `<div style="font-weight: 600; color: #333; margin-bottom: 4px;">${variantLabel}</div>`;
                            graphsHtml += `<div style="font-size: 12px; color: #666;">${variantInfoHtml}</div>`;
                            
                            // Events info with positive/negative split
                            if (eventsCount > 0) {
                                const positiveText = positiveEvents > 0 ? `${positiveEvents} ${positiveEvents === 1 ? '–ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ' : positiveEvents < 5 ? '–ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã—Ö' : '–ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã—Ö'}` : '';
                                const negativeText = negativeEvents > 0 ? `${negativeEvents} ${negativeEvents === 1 ? '–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ' : negativeEvents < 5 ? '–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã—Ö' : '–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã—Ö'}` : '';
                                let eventsText = '';
                                if (positiveText && negativeText) {
                                    eventsText = `üü¢ ${positiveText}, üî¥ ${negativeText}`;
                                } else if (positiveText) {
                                    eventsText = `üü¢ ${positiveText}`;
                                } else if (negativeText) {
                                    eventsText = `üî¥ ${negativeText}`;
                                } else {
                                    eventsText = `‚ö™ ${eventsCount} ${eventsCount === 1 ? '—Å–æ–±—ã—Ç–∏–µ' : eventsCount < 5 ? '—Å–æ–±—ã—Ç–∏—è' : '—Å–æ–±—ã—Ç–∏–π'}`;
                                }
                                graphsHtml += `<div style="margin-top: 6px; font-size: 12px; font-weight: 500; color: #333;">${eventsText}</div>`;
                            } else {
                                graphsHtml += `<div style="margin-top: 6px; font-size: 12px; font-weight: 500; color: #666;">‚ö™ –ù–µ—Ç —Å–æ–±—ã—Ç–∏–π</div>`;
                            }
                            const detectorSummaryHtml = renderDetectorSummaryList(
                                summarizeDetectorResults(viz.detectorResults || []),
                                { wrapperStyle: 'margin-top: 8px; font-size: 11px; color: #444;' }
                            );
                            if (detectorSummaryHtml) {
                                graphsHtml += detectorSummaryHtml;
                            }
                            graphsHtml += `<div style="margin-top: 8px; display: flex; gap: 8px; flex-wrap: wrap;">`;
                            graphsHtml += `<a href="${viz.path}" target="_blank" onclick="event.stopPropagation();" style="padding: 4px 8px; background: #2196F3; color: white; text-decoration: none; border-radius: 4px; font-size: 11px;">üîó –û—Ç–∫—Ä—ã—Ç—å</a>`;
                            graphsHtml += `<span style="padding: 4px 8px; background: #e0e0e0; color: #666; border-radius: 4px; font-size: 11px; cursor: pointer;" onclick="event.stopPropagation(); expandThumbnail(this)">üîç –£–≤–µ–ª–∏—á–∏—Ç—å</span>`;
                            // Add "Save Data" button
                            const dataFilename = viz.path.split('/').pop().replace('.html', '_data.json');
                            graphsHtml += `<a href="/api/viz-data/${dataFilename}" onclick="event.stopPropagation();" download="${dataFilename}" style="padding: 4px 8px; background: #4CAF50; color: white; text-decoration: none; border-radius: 4px; font-size: 11px;">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –¥–∞–Ω–Ω—ã–µ</a>`;
                            graphsHtml += `</div>`;
                            graphsHtml += `</div>`;
                            graphsHtml += `</div>`;
                        });
                        
                        graphsHtml += '</div>'; // Close grid for this metric
                        graphsHtml += '</div>'; // Close metric section
                    }
                });
            } else {
                graphsHtml = '<div style="padding: 20px; text-align: center; color: #666;">–ì—Ä–∞—Ñ–∏–∫–∏ –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã</div>';
            }
            
            container.innerHTML = graphsHtml;
            container.style.display = 'block';
            
            // Initialize lazy loading for new iframes
            setTimeout(() => {
                initializeLazyLoading();
            }, 100);
        }
        
        function filterVisualizations(metric) {
            const galleries = document.querySelectorAll('.metric-gallery');
            galleries.forEach(gallery => {
                if (metric === 'all') {
                    gallery.style.display = 'block';
                } else if (gallery.dataset.metric === metric) {
                    gallery.style.display = 'block';
                } else {
                    gallery.style.display = 'none';
                }
            });
        }
        
        function openVisualization(path, variantLabel) {
            // Open in new tab
            window.open(path, '_blank');
        }
        
        function expandThumbnail(element) {
            const card = element.closest('div[onclick]');
            if (!card) return;
            
            const iframe = card.querySelector('iframe');
            if (!iframe) return;
            
            // Create modal
            const modal = document.createElement('div');
            modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 20px;';
            modal.onclick = function(e) {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            };
            
            const content = document.createElement('div');
            content.style.cssText = 'background: white; border-radius: 8px; padding: 20px; max-width: 95%; max-height: 95%; overflow: auto; position: relative;';
            content.onclick = function(e) { e.stopPropagation(); };
            
            const closeBtn = document.createElement('button');
            closeBtn.textContent = '‚úï';
            closeBtn.style.cssText = 'position: absolute; top: 10px; right: 10px; background: #f44336; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; font-size: 18px; line-height: 1;';
            closeBtn.onclick = function() { document.body.removeChild(modal); };
            
            const expandedIframe = document.createElement('iframe');
            expandedIframe.src = iframe.src;
            expandedIframe.style.cssText = 'width: 90vw; height: 80vh; border: none; border-radius: 4px;';
            
            content.appendChild(closeBtn);
            content.appendChild(expandedIframe);
            modal.appendChild(content);
            document.body.appendChild(modal);
        }
        
        function loadConfigFromSelect() {
            const select = document.getElementById('configsSelect');
            const configPath = select.value;
            
            // Don't load if no config selected (empty value)
            if (!configPath) {
                document.getElementById('fileName').textContent = '';
                return;
            }
            
            // Load config file from server
            fetch(`/api/config?path=${encodeURIComponent(configPath)}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–æ–Ω—Ñ–∏–≥–∞');
                    }
                    return response.text();
                })
                .then(yamlText => {
                    try {
                        // Parse YAML
                        const config = parseYAML(yamlText);
                        console.log('Parsed config:', JSON.stringify(config, null, 2));
                        
                        // Fill form with loaded values
                        fillFormFromConfig(config);
                        
                        // Update file name display
                        const fileName = configPath.split('/').pop();
                        document.getElementById('fileName').textContent = 'üìÑ ' + fileName;
                        
                        // Generate preview
                        setTimeout(function() {
                            generateConfig();
                        }, 100);
                    } catch (error) {
                        alert('–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –∫–æ–Ω—Ñ–∏–≥–∞: ' + error.message);
                        console.error('Parse error:', error);
                        document.getElementById('fileName').textContent = '';
                    }
                })
                .catch(error => {
                    alert('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–æ–Ω—Ñ–∏–≥–∞: ' + error.message);
                    console.error('Load error:', error);
                    document.getElementById('fileName').textContent = '';
                });
        }
        
        function loadYamlFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            document.getElementById('fileName').textContent = 'üìÑ ' + file.name;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const yamlText = e.target.result;
                    // Parse YAML (simple parser for basic YAML structure)
                    const config = parseYAML(yamlText);
                    // Debug: log parsed config
                    console.log('Parsed config:', JSON.stringify(config, null, 2));
                    // Fill form with loaded values
                    fillFormFromConfig(config);
                    // Generate preview after a small delay to ensure DOM is updated
                    setTimeout(function() {
                        generateConfig();
                    }, 100);
                } catch (error) {
                    alert('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞: ' + error.message);
                    console.error('Parse error:', error);
                    console.error('YAML text:', yamlText);
                }
            };
            reader.readAsText(file);
        }
        
        function parseYAML(yamlText) {
            // Improved YAML parser for basic structures
            const lines = yamlText.split('\n');
            const config = {};
            const path = []; // Stack to track current path
            let multilineMode = false;
            let multilineKey = null;
            let multilinePath = [];
            let multilineContent = [];
            let multilineIndent = 0;
            let lastArrayKey = null; // Track last declared array key
            let lastArrayPath = []; // Track path to last array
            
            function setValue(obj, pathArray, value) {
                let current = obj;
                for (let i = 0; i < pathArray.length - 1; i++) {
                    const key = pathArray[i];
                    if (!current[key] || typeof current[key] !== 'object' || Array.isArray(current[key])) {
                        current[key] = {};
                    }
                    current = current[key];
                }
                current[pathArray[pathArray.length - 1]] = value;
            }
            
            function getCurrentObject() {
                let current = config;
                for (const key of path) {
                    if (!current[key]) current[key] = {};
                    if (Array.isArray(current[key])) {
                        // If it's an array, we need to work with the parent
                        return null;
                    }
                    current = current[key];
                }
                return current;
            }
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmed = line.trim();
                const indent = line.length - line.trimStart().length;
                
                // Handle multiline strings
                if (multilineMode) {
                    // Check if we should continue multiline
                    // Continue if: indent is greater than multiline indent, OR
                    //              indent equals multiline indent and line is not empty, OR
                    //              line is empty but we're still in the multiline block
                    if (indent >= multilineIndent) {
                        // Still in multiline - add content (preserve original indentation relative to multiline start)
                        if (trimmed === '' && multilineContent.length > 0) {
                            // Empty line in multiline - preserve it
                            multilineContent.push('');
                        } else if (indent >= multilineIndent) {
                            multilineContent.push(line.substring(Math.min(indent, multilineIndent)));
                        }
                    } else {
                        // End of multiline - save and continue
                        const value = multilineContent.join('\n');
                        // Remove trailing empty lines but keep the structure
                        const trimmedValue = value.replace(/\n+$/, '');
                        setValue(config, multilinePath, trimmedValue);
                        multilineMode = false;
                        multilineKey = null;
                        multilinePath = [];
                        multilineContent = [];
                        i--; // Re-process this line
                        continue;
                    }
                    continue;
                }
                
                // Skip empty lines and comments
                if (trimmed === '' || trimmed.startsWith('#')) {
                    continue;
                }
                
                // Check for multiline string start (|)
                const colonIndex = trimmed.indexOf(':');
                if (colonIndex > 0) {
                    const key = trimmed.substring(0, colonIndex).trim();
                    let value = trimmed.substring(colonIndex + 1).trim();
                    
                    // Check for multiline indicator
                    if (value === '|' || value === '|+') {
                        multilineMode = true;
                        multilineKey = key;
                        multilineIndent = indent;
                        multilinePath = [...path, key];
                        multilineContent = [];
                        continue;
                    }
                }
                
                // Calculate path depth based on indent (YAML uses 2 spaces per level typically)
                const pathDepth = Math.floor(indent / 2);
                while (path.length > pathDepth) {
                    path.pop();
                }
                
                // Parse key-value pairs
                if (colonIndex > 0 && !trimmed.startsWith('-')) {
                    const key = trimmed.substring(0, colonIndex).trim();
                    let value = trimmed.substring(colonIndex + 1).trim();
                    
                    // Remove quotes
                    if ((value.startsWith('"') && value.endsWith('"')) || 
                        (value.startsWith("'") && value.endsWith("'"))) {
                        value = value.slice(1, -1);
                    }
                    
                    // Remove inline comments
                    const commentIdx = value.indexOf(' #');
                    if (commentIdx > 0) {
                        value = value.substring(0, commentIdx).trim();
                    }
                    
                    // Check for inline array format: ["item1", "item2"] or [item1, item2]
                    if (value.startsWith('[') && value.endsWith(']')) {
                        const arrayContent = value.slice(1, -1).trim();
                        if (arrayContent === '') {
                            // Empty array
                            setValue(config, path.concat([key]), []);
                            lastArrayKey = key;
                            lastArrayPath = [...path, key];
                        } else {
                            // Parse inline array
                            const items = [];
                            // Split by comma, but respect quotes
                            let currentItem = '';
                            let inQuotes = false;
                            let quoteChar = null;
                            
                            for (let charIdx = 0; charIdx < arrayContent.length; charIdx++) {
                                const char = arrayContent[charIdx];
                                
                                if (!inQuotes && (char === '"' || char === "'")) {
                                    // Start of quoted string - don't add quote to currentItem
                                    inQuotes = true;
                                    quoteChar = char;
                                } else if (inQuotes && char === quoteChar) {
                                    // End of quoted string - don't add quote to currentItem
                                    inQuotes = false;
                                    quoteChar = null;
                                    // Don't add the closing quote to currentItem
                                } else if (!inQuotes && char === ',') {
                                    // Comma outside quotes - end of item
                                    items.push(currentItem.trim());
                                    currentItem = '';
                                } else {
                                    // Regular character - add to current item
                                    currentItem += char;
                                }
                            }
                            // Add last item if exists
                            if (currentItem.trim()) {
                                items.push(currentItem.trim());
                            }
                            
                            // Items are already cleaned (quotes were not added to currentItem)
                            setValue(config, path.concat([key]), items);
                            lastArrayKey = key;
                            lastArrayPath = [...path, key];
                        }
                    }
                    // Parse value type
                    else {
                        let parsedValue = value;
                        
                        // Remove quotes if present (but keep the value as string)
                        let unquotedValue = value;
                        if ((value.startsWith('"') && value.endsWith('"')) || 
                            (value.startsWith("'") && value.endsWith("'"))) {
                            unquotedValue = value.slice(1, -1);
                        }
                        
                        // Parse value type based on unquoted value
                        if (unquotedValue === 'true') parsedValue = true;
                        else if (unquotedValue === 'false') parsedValue = false;
                        else if (unquotedValue === 'null' || unquotedValue === '') parsedValue = null;
                        else if (unquotedValue !== '' && !isNaN(unquotedValue) && unquotedValue.trim() !== '') {
                            parsedValue = unquotedValue.includes('.') ? parseFloat(unquotedValue) : parseInt(unquotedValue);
                        } else {
                            // Keep as string (use unquoted value)
                            parsedValue = unquotedValue;
                        }
                        
                        // Check if this is an array declaration
                        if (value === '' || value === '[]') {
                            setValue(config, path.concat([key]), []);
                            lastArrayKey = key;
                            lastArrayPath = [...path, key];
                            path.push(key);
                        } else if (value !== '') {
                            setValue(config, path.concat([key]), parsedValue);
                            lastArrayKey = null; // Clear array tracking when we set a value
                        } else {
                            // Empty value means nested object
                            setValue(config, path.concat([key]), {});
                            lastArrayKey = null; // Clear array tracking
                            path.push(key);
                        }
                    }
                }
                // Parse array items
                else if (trimmed.startsWith('- ')) {
                    const arrayValue = trimmed.substring(2).trim();
                    // Remove quotes
                    let cleanValue = arrayValue;
                    if ((arrayValue.startsWith('"') && arrayValue.endsWith('"')) || 
                        (arrayValue.startsWith("'") && arrayValue.endsWith("'"))) {
                        cleanValue = arrayValue.slice(1, -1);
                    }
                    
                    // Remove inline comments (everything after #)
                    const commentIndex = cleanValue.indexOf(' #');
                    if (commentIndex > 0) {
                        cleanValue = cleanValue.substring(0, commentIndex).trim();
                    }
                    
                    // Try to find the array this item belongs to
                    let added = false;
                    
                    // First, check if we have a tracked array at the current path level
                    if (lastArrayKey && lastArrayPath.length > 0) {
                        // Check if current path matches array path
                        const pathDepth = Math.floor(indent / 2);
                        const arrayPathDepth = lastArrayPath.length;
                        
                        // Check if we're at the right indent level (array items are typically 2 spaces more than array declaration)
                        if (pathDepth === arrayPathDepth) {
                            // Check if path matches
                            const pathMatch = lastArrayPath.every((key, idx) => 
                                idx < path.length && path[idx] === key
                            );
                            
                            if (pathMatch) {
                                // Add to tracked array
                                let target = config;
                                for (const p of lastArrayPath) {
                                    if (!target[p]) target[p] = [];
                                    target = target[p];
                                }
                                if (Array.isArray(target)) {
                                    target.push(cleanValue);
                                    added = true;
                                }
                            }
                        }
                    }
                    
                    // If not added, look for array in current context
                    if (!added) {
                        const parent = getCurrentObject();
                        if (parent) {
                            const lastKey = path[path.length - 1];
                            if (lastKey && Array.isArray(parent[lastKey])) {
                                parent[lastKey].push(cleanValue);
                                added = true;
                            } else {
                                // Look backwards for array declaration
                                // Array items are typically at indent level = array declaration indent + 2
                                const expectedIndent = indent - 2;
                                
                                // Reconstruct the path up to the expected indent level
                                const arrayPath = [];
                                for (let k = 0; k < i; k++) {
                                    const checkLine = lines[k];
                                    const checkIndent = checkLine.length - checkLine.trimStart().length;
                                    const checkTrimmed = checkLine.trim();
                                    
                                    if (checkTrimmed && !checkTrimmed.startsWith('#') && checkTrimmed.includes(':') && !checkTrimmed.startsWith('-')) {
                                        const checkKey = checkTrimmed.substring(0, checkTrimmed.indexOf(':')).trim();
                                        const checkValue = checkTrimmed.substring(checkTrimmed.indexOf(':') + 1).trim();
                                        const checkDepth = Math.floor(checkIndent / 2);
                                        
                                        // Build path up to expected depth
                                        while (arrayPath.length > checkDepth) {
                                            arrayPath.pop();
                                        }
                                        if (arrayPath.length === checkDepth) {
                                            arrayPath.push(checkKey);
                                        }
                                        
                                        // Check if this is the array declaration we're looking for
                                        if (checkIndent === expectedIndent && (checkValue === '' || checkValue === '[]')) {
                                            // Found the array declaration - use current path
                                            let target = config;
                                            for (let p = 0; p < arrayPath.length - 1; p++) {
                                                if (!target[arrayPath[p]]) target[arrayPath[p]] = {};
                                                target = target[arrayPath[p]];
                                            }
                                            const arrayKey = arrayPath[arrayPath.length - 1];
                                            if (!target[arrayKey] || !Array.isArray(target[arrayKey])) {
                                                target[arrayKey] = [];
                                            }
                                            target[arrayKey].push(cleanValue);
                                            added = true;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        
                        // If still not added, try top-level arrays
                        if (!added && path.length === 0) {
                            // Look for top-level array
                            for (let j = i - 1; j >= 0 && j >= i - 30; j--) {
                                const prevLine = lines[j].trim();
                                if (prevLine && !prevLine.startsWith('#') && prevLine.includes(':')) {
                                    const prevKey = prevLine.substring(0, prevLine.indexOf(':')).trim();
                                    const prevValue = prevLine.substring(prevLine.indexOf(':') + 1).trim();
                                    if ((prevValue === '' || prevValue === '[]') && config[prevKey] && Array.isArray(config[prevKey])) {
                                        config[prevKey].push(cleanValue);
                                        added = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
                // Parse section headers (key with colon at end, no value)
                else if (trimmed.endsWith(':') && colonIndex === trimmed.length - 1) {
                    const key = trimmed.slice(0, -1).trim();
                    setValue(config, path.concat([key]), {});
                    path.push(key);
                }
            }
            
            // Handle trailing multiline
            if (multilineMode && multilineContent.length > 0) {
                const value = multilineContent.join('\n');
                const trimmedValue = value.replace(/\n+$/, '');
                setValue(config, multilinePath, trimmedValue);
            }
            
            return config;
        }
        
        function fillFormFromConfig(config) {
            // Fill job section
            if (config.job) {
                if (config.job.name) document.getElementById('jobName').value = config.job.name;
                if (config.job.description) document.getElementById('jobDescription').value = config.job.description;
            }
            
            // Fill data_source section
            if (config.data_source) {
                if (config.data_source.ydb && config.data_source.ydb.query) {
                    document.getElementById('ydbQuery').value = config.data_source.ydb.query;
                }
                if (config.data_source.aggregate_by) {
                    document.getElementById('aggregateBy').value = config.data_source.aggregate_by;
                }
            }
            
            // Fill context_fields
            if (config.context_fields && Array.isArray(config.context_fields)) {
                const container = document.getElementById('contextFields');
                container.innerHTML = '';
                config.context_fields.forEach(field => {
                    addArrayItem('contextFields');
                    const lastInput = container.querySelector('.array-input:last-child input');
                    if (lastInput) lastInput.value = field;
                });
            }
            
            // Fill metric_fields
            if (config.metric_fields && Array.isArray(config.metric_fields)) {
                const container = document.getElementById('metricFields');
                container.innerHTML = '';
                config.metric_fields.forEach((field, index) => {
                    const div = document.createElement('div');
                    div.className = 'array-input';
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = field;
                    input.readOnly = true;
                    const button = document.createElement('button');
                    button.type = 'button';
                    button.className = 'btn-remove';
                    button.disabled = true;
                    button.textContent = '√ó';
                    div.appendChild(input);
                    div.appendChild(button);
                    container.appendChild(div);
                });
            }
            
            // Fill timestamp_field
            if (config.timestamp_field) {
                document.getElementById('timestampField').value = config.timestamp_field;
            }
            
            // Fill analytics section
            if (config.analytics) {
                if (config.analytics.baseline_method) {
                    document.getElementById('baselineMethod').value = config.analytics.baseline_method;
                }
                if (config.analytics.window_size) {
                    document.getElementById('windowSize').value = config.analytics.window_size;
                }
                if (config.analytics.sensitivity) {
                    document.getElementById('sensitivity').value = config.analytics.sensitivity;
                }
                if (config.analytics.min_absolute_change !== undefined) {
                    document.getElementById('minAbsoluteChange').value = config.analytics.min_absolute_change;
                }
                if (config.analytics.min_relative_change !== undefined) {
                    document.getElementById('minRelativeChange').value = config.analytics.min_relative_change;
                }
                if (config.analytics.hysteresis_points) {
                    document.getElementById('hysteresisPoints').value = config.analytics.hysteresis_points;
                }
                if (config.analytics.adaptive_threshold !== undefined) {
                    document.getElementById('adaptiveThreshold').checked = config.analytics.adaptive_threshold;
                }
                if (config.analytics.min_data_points) {
                    document.getElementById('minDataPoints').value = config.analytics.min_data_points;
                }
            }
            
            // Fill metric_direction
            if (config.metric_direction) {
                console.log('Filling metric_direction:', config.metric_direction);
                console.log('metric_direction type:', typeof config.metric_direction);
                console.log('metric_direction keys:', Object.keys(config.metric_direction));
                
                if (config.metric_direction.default) {
                    const defaultEl = document.getElementById('metricDirectionDefault');
                    if (defaultEl) {
                        // Clean default value - remove quotes if present
                        let defaultValue = config.metric_direction.default;
                        if (typeof defaultValue === 'string') {
                            defaultValue = defaultValue.trim();
                            if ((defaultValue.startsWith('"') && defaultValue.endsWith('"')) || 
                                (defaultValue.startsWith("'") && defaultValue.endsWith("'"))) {
                                defaultValue = defaultValue.slice(1, -1).trim();
                            }
                        }
                        defaultEl.value = defaultValue;
                        console.log('Set default direction to:', defaultValue);
                    }
                }
                
                // Clear existing metric directions
                const metricDirectionsContainer = document.getElementById('metricDirections');
                if (metricDirectionsContainer) {
                    metricDirectionsContainer.innerHTML = '';
                    
                    // Process all entries in metric_direction
                    Object.entries(config.metric_direction).forEach(([key, value]) => {
                        if (key !== 'default') {
                            console.log(`Processing metric direction: ${key} = ${value} (type: ${typeof value})`);
                            
                            // Clean value - remove quotes and trim
                            let cleanValue = value;
                            if (typeof value === 'string') {
                                cleanValue = value.trim();
                                // Remove surrounding quotes if present
                                if ((cleanValue.startsWith('"') && cleanValue.endsWith('"')) || 
                                    (cleanValue.startsWith("'") && cleanValue.endsWith("'"))) {
                                    cleanValue = cleanValue.slice(1, -1).trim();
                                }
                            }
                            
                            console.log(`Cleaned value for ${key}: "${cleanValue}"`);
                            
                            // More flexible check - allow any string that contains 'positive' or 'negative'
                            const isPositive = cleanValue === 'positive' || 
                                              (typeof cleanValue === 'string' && cleanValue.toLowerCase().includes('positive'));
                            const isNegative = cleanValue === 'negative' || 
                                              (typeof cleanValue === 'string' && cleanValue.toLowerCase().includes('negative'));
                            
                            if (isPositive || isNegative) {
                                const finalValue = isPositive ? 'positive' : 'negative';
                                console.log(`Creating metric direction: ${key} = ${finalValue}`);
                                
                                // Create element and get reference directly
                                const container = document.getElementById('metricDirections');
                                const div = document.createElement('div');
                                div.className = 'metric-direction-item';
                                div.style.display = 'grid';
                                div.style.gridTemplateColumns = '1fr auto auto';
                                div.style.gap = '10px';
                                div.style.marginBottom = '10px';
                                
                                const nameInput = document.createElement('input');
                                nameInput.type = 'text';
                                nameInput.className = 'metric-name';
                                nameInput.placeholder = '–∏–º—è_–º–µ—Ç—Ä–∏–∫–∏';
                                nameInput.value = key; // Set value immediately
                                
                                const directionSelect = document.createElement('select');
                                directionSelect.className = 'metric-direction';
                                const opt1 = document.createElement('option');
                                opt1.value = 'negative';
                                opt1.textContent = 'negative';
                                const opt2 = document.createElement('option');
                                opt2.value = 'positive';
                                opt2.textContent = 'positive';
                                directionSelect.appendChild(opt1);
                                directionSelect.appendChild(opt2);
                                
                                const removeBtn = document.createElement('button');
                                removeBtn.type = 'button';
                                removeBtn.className = 'btn-remove';
                                removeBtn.textContent = '√ó';
                                removeBtn.onclick = function() { div.remove(); };
                                
                                div.appendChild(nameInput);
                                div.appendChild(directionSelect);
                                div.appendChild(removeBtn);
                                container.appendChild(div);
                                
                                // Set value AFTER element is added to DOM
                                directionSelect.value = finalValue;
                                
                                // Verify and fix if needed
                                if (directionSelect.value !== finalValue) {
                                    console.warn(`Failed to set select value to ${finalValue}, current: ${directionSelect.value}`);
                                    // Try setting selectedIndex
                                    for (let i = 0; i < directionSelect.options.length; i++) {
                                        if (directionSelect.options[i].value === finalValue) {
                                            directionSelect.selectedIndex = i;
                                            break;
                                        }
                                    }
                                }
                                console.log(`Successfully set ${key} direction to: ${directionSelect.value}`);
                            } else {
                                console.warn(`Skipping ${key} with value "${cleanValue}" - not recognized as positive or negative`);
                            }
                        }
                    });
                    
                    console.log(`Total metric directions created: ${metricDirectionsContainer.children.length}`);
                }
            } else {
                console.log('No metric_direction found in config');
            }
            
            // Fill context_tracking
            if (config.context_tracking) {
                if (config.context_tracking.track_new_contexts !== undefined) {
                    document.getElementById('trackNewContexts').checked = config.context_tracking.track_new_contexts;
                }
                if (config.context_tracking.track_disappeared_contexts !== undefined) {
                    document.getElementById('trackDisappearedContexts').checked = config.context_tracking.track_disappeared_contexts;
                }
                if (config.context_tracking.context_change_rules) {
                    const rules = config.context_tracking.context_change_rules;
                    if (rules.new_context_metrics) {
                        const metricName = Object.keys(rules.new_context_metrics)[0];
                        if (metricName) {
                            const newContextMetricEl = document.getElementById('newContextMetric');
                            if (newContextMetricEl) newContextMetricEl.value = metricName;
                            const rule = rules.new_context_metrics[metricName];
                            if (rule.event_type) {
                                const newContextEventTypeEl = document.getElementById('newContextEventType');
                                if (newContextEventTypeEl) newContextEventTypeEl.value = rule.event_type;
                            }
                            if (rule.severity) {
                                const newContextSeverityEl = document.getElementById('newContextSeverity');
                                if (newContextSeverityEl) newContextSeverityEl.value = rule.severity;
                            }
                            if (rule.min_value !== undefined) {
                                const newContextMinValueEl = document.getElementById('newContextMinValue');
                                if (newContextMinValueEl) newContextMinValueEl.value = rule.min_value;
                            }
                        }
                    }
                    if (rules.disappeared_context_metrics) {
                        const metricName = Object.keys(rules.disappeared_context_metrics)[0];
                        if (metricName) {
                            const disappearedContextMetricEl = document.getElementById('disappearedContextMetric');
                            if (disappearedContextMetricEl) disappearedContextMetricEl.value = metricName;
                            const rule = rules.disappeared_context_metrics[metricName];
                            if (rule.event_type) {
                                const disappearedContextEventTypeEl = document.getElementById('disappearedContextEventType');
                                if (disappearedContextEventTypeEl) disappearedContextEventTypeEl.value = rule.event_type;
                            }
                            if (rule.severity) {
                                const disappearedContextSeverityEl = document.getElementById('disappearedContextSeverity');
                                if (disappearedContextSeverityEl) disappearedContextSeverityEl.value = rule.severity;
                            }
                            if (rule.min_absence_points !== undefined) {
                                const minAbsencePointsEl = document.getElementById('minAbsencePoints');
                                if (minAbsencePointsEl) minAbsencePointsEl.value = rule.min_absence_points;
                            }
                            if (rule.min_absence_duration_minutes !== undefined) {
                                const minAbsenceDurationEl = document.getElementById('minAbsenceDuration');
                                if (minAbsenceDurationEl) minAbsenceDurationEl.value = rule.min_absence_duration_minutes;
                            }
                            if (rule.absence_type) {
                                const absenceTypeEl = document.getElementById('absenceType');
                                if (absenceTypeEl) absenceTypeEl.value = rule.absence_type;
                            }
                            if (rule.min_historical_points !== undefined) {
                                const minHistoricalPointsEl = document.getElementById('minHistoricalPoints');
                                if (minHistoricalPointsEl) minHistoricalPointsEl.value = rule.min_historical_points;
                            }
                        }
                    }
                }
            }
            
            // Fill events
            if (config.events) {
                console.log('Filling events:', config.events);
                if (config.events.detect) {
                    let detectArray = Array.isArray(config.events.detect) ? config.events.detect : [];
                    // Clean array items from comments and trim whitespace
                    detectArray = detectArray.map(item => {
                        if (typeof item === 'string') {
                            // Remove inline comments
                            const commentIdx = item.indexOf(' #');
                            if (commentIdx > 0) {
                                item = item.substring(0, commentIdx);
                            }
                            return item.trim();
                        }
                        return item;
                    });
                    console.log('Events detect array (cleaned):', detectArray);
                    
                    const detectDegradationEl = document.getElementById('detectDegradation');
                    const detectImprovementEl = document.getElementById('detectImprovement');
                    const detectThresholdShiftEl = document.getElementById('detectThresholdShift');
                    
                    console.log('Found elements:', {
                        degradation: !!detectDegradationEl,
                        improvement: !!detectImprovementEl,
                        thresholdShift: !!detectThresholdShiftEl
                    });
                    
                    if (detectDegradationEl) {
                        detectDegradationEl.checked = detectArray.includes('degradation_start');
                        console.log('Set degradation to:', detectDegradationEl.checked);
                    }
                    if (detectImprovementEl) {
                        detectImprovementEl.checked = detectArray.includes('improvement_start');
                        console.log('Set improvement to:', detectImprovementEl.checked);
                    }
                    if (detectThresholdShiftEl) {
                        detectThresholdShiftEl.checked = detectArray.includes('threshold_shift');
                        console.log('Set threshold_shift to:', detectThresholdShiftEl.checked);
                    }
                }
                if (config.events.output_table) {
                    const eventsTableEl = document.getElementById('eventsOutputTable');
                    if (eventsTableEl) eventsTableEl.value = config.events.output_table;
                }
                if (config.events.min_event_duration_minutes) {
                    const minDurationEl = document.getElementById('minEventDuration');
                    if (minDurationEl) minDurationEl.value = config.events.min_event_duration_minutes;
                }
                applyDetectorsFromConfig(config.events);
            }
            
            // Fill thresholds
            if (config.thresholds) {
                if (config.thresholds.output_table) {
                    document.getElementById('thresholdsOutputTable').value = config.thresholds.output_table;
                }
                if (config.thresholds.keep_history !== undefined) {
                    document.getElementById('keepHistory').checked = config.thresholds.keep_history;
                }
            }
            
            // Fill output
            if (config.output) {
                if (config.output.write_to_ydb !== undefined) {
                    document.getElementById('writeToYdb').checked = config.output.write_to_ydb;
                }
                if (config.output.log_to_console !== undefined) {
                    document.getElementById('logToConsole').checked = config.output.log_to_console;
                }
                if (config.output.dry_run !== undefined) {
                    document.getElementById('dryRun').checked = config.output.dry_run;
                }
            }
            
            // Fill runtime
            if (config.runtime) {
                if (config.runtime.timezone) {
                    document.getElementById('timezone').value = config.runtime.timezone;
                }
                if (config.runtime.max_runtime_minutes) {
                    document.getElementById('maxRuntime').value = config.runtime.max_runtime_minutes;
                }
            }
        }
        
        function toggleCollapse(element) {
            element.classList.toggle('collapsed');
            const content = element.nextElementSibling;
            content.classList.toggle('collapsed');
        }
        
        function addArrayItem(containerId) {
            const container = document.getElementById(containerId);
            const div = document.createElement('div');
            div.className = 'array-input';
            
            const input = document.createElement('input');
            input.type = 'text';
            input.placeholder = '–Ω–æ–≤–æ–µ –ø–æ–ª–µ';
            
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'btn-remove';
            button.textContent = '√ó';
            button.onclick = function() { removeArrayItem(this); };
            
            div.appendChild(input);
            div.appendChild(button);
            container.appendChild(div);
        }
        
        function removeArrayItem(button) {
            button.parentElement.remove();
        }
        
        function addMetricDirection() {
            const container = document.getElementById('metricDirections');
            const div = document.createElement('div');
            div.className = 'metric-direction-item';
            div.style.display = 'grid';
            div.style.gridTemplateColumns = '1fr auto auto';
            div.style.gap = '10px';
            div.style.marginBottom = '10px';
            
            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.className = 'metric-name';
            nameInput.placeholder = '–∏–º—è_–º–µ—Ç—Ä–∏–∫–∏';
            
            const directionSelect = document.createElement('select');
            directionSelect.className = 'metric-direction';
            const opt1 = document.createElement('option');
            opt1.value = 'negative';
            opt1.textContent = 'negative';
            const opt2 = document.createElement('option');
            opt2.value = 'positive';
            opt2.textContent = 'positive';
            directionSelect.appendChild(opt1);
            directionSelect.appendChild(opt2);
            
            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'btn-remove';
            removeBtn.textContent = '√ó';
            removeBtn.onclick = function() { removeArrayItem(this); };
            
            div.appendChild(nameInput);
            div.appendChild(directionSelect);
            div.appendChild(removeBtn);
            container.appendChild(div);
        }
        
        function getArrayValues(containerId) {
            const container = document.getElementById(containerId);
            const inputs = container.querySelectorAll('input[type="text"]');
            return Array.from(inputs).map(input => input.value.trim()).filter(v => v);
        }
        
        function getMetricDirections() {
            const container = document.getElementById('metricDirections');
            const items = container.querySelectorAll('.metric-direction-item');
            const result = {};
            items.forEach(item => {
                const name = item.querySelector('.metric-name').value.trim();
                const direction = item.querySelector('.metric-direction').value;
                if (name) {
                    result[name] = direction;
                }
            });
            return result;
        }
        
        const AVAILABLE_DETECTORS = [
            {
                id: 'baseline_threshold',
                label: 'Baseline Threshold',
                type: 'threshold',
                description: '–î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –ø–æ—Ä–æ–≥–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–∞—Å—á–µ—Ç–Ω–æ–≥–æ baseline',
                defaultEnabled: true,
                params: []
            },
            {
                id: 'pyod_iforest',
                label: 'PyOD Isolation Forest',
                type: 'pyod_iforest',
                description: '–ú–æ–¥–µ–ª—å PyOD Isolation Forest –¥–ª—è –ø–æ–∏—Å–∫–∞ –≤—ã–±—Ä–æ—Å–æ–≤',
                defaultEnabled: false,
                params: [
                    { key: 'contamination', label: '–î–æ–ª—è –≤—ã–±—Ä–æ—Å–æ–≤', type: 'number', step: '0.01', min: '0', max: '0.5', default: '0.1' },
                    { key: 'min_points', label: '–ú–∏–Ω. —Ç–æ—á–µ–∫', type: 'number', min: '10', default: '15' }
                ]
            },
            {
                id: 'ruptures_binseg',
                label: 'Ruptures Change Point',
                type: 'ruptures',
                description: 'Change-point –∞–Ω–∞–ª–∏–∑ (Binseg) –¥–ª—è –ø–æ–∏—Å–∫–∞ —Å–¥–≤–∏–≥–æ–≤ baseline',
                defaultEnabled: false,
                params: [
                    { key: 'penalty', label: 'Penalty', type: 'number', min: '1', default: '10' },
                    { key: 'window', label: 'Window', type: 'number', min: '5', default: '10' }
                ]
            }
        ];
        
        function renderDetectorControls() {
            const container = document.getElementById('detectorsContainer');
            if (!container) return;
            container.innerHTML = '';
            
            AVAILABLE_DETECTORS.forEach(detector => {
                const item = document.createElement('div');
                item.className = 'detector-item';
                item.dataset.detectorId = detector.id;
                
                const header = document.createElement('div');
                header.className = 'detector-header';
                
                const label = document.createElement('label');
                label.className = 'checkbox-group';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'detector-toggle';
                checkbox.dataset.detectorId = detector.id;
                checkbox.checked = detector.defaultEnabled || detector.id === 'baseline_threshold';
                if (detector.id === 'baseline_threshold') {
                    checkbox.disabled = true;
                }
                
                const caption = document.createElement('span');
                caption.textContent = detector.label;
                
                label.appendChild(checkbox);
                label.appendChild(caption);
                
                header.appendChild(label);
                
                item.appendChild(header);
                
                if (detector.description) {
                    const description = document.createElement('div');
                    description.className = 'detector-description';
                    description.textContent = detector.description;
                    item.appendChild(description);
                }
                
                if (detector.params && detector.params.length > 0) {
                    const paramsWrapper = document.createElement('div');
                    paramsWrapper.className = 'detector-params';
                    
                    detector.params.forEach(param => {
                        const paramDiv = document.createElement('div');
                        paramDiv.className = 'detector-param';
                        const paramLabel = document.createElement('label');
                        paramLabel.textContent = param.label;
                        
                        const input = document.createElement('input');
                        input.type = param.type || 'text';
                        input.dataset.paramKey = param.key;
                        if (param.step) input.step = param.step;
                        if (param.min !== undefined) input.min = param.min;
                        if (param.max !== undefined) input.max = param.max;
                        if (param.default !== undefined) input.value = param.default;
                        
                        paramLabel.appendChild(input);
                        paramDiv.appendChild(paramLabel);
                        paramsWrapper.appendChild(paramDiv);
                    });
                    
                    item.appendChild(paramsWrapper);
                }
                
                container.appendChild(item);
            });
            
            const toggles = container.querySelectorAll('.detector-toggle');
            toggles.forEach(toggle => {
                toggle.addEventListener('change', () => {
                    updateDetectorSelects();
                });
            });
            
            updateDetectorSelects();
        }
        
        function getEnabledDetectors() {
            const enabled = [];
            AVAILABLE_DETECTORS.forEach(detector => {
                const item = document.querySelector(`.detector-item[data-detector-id="${detector.id}"]`);
                if (!item) return;
                const toggle = item.querySelector('.detector-toggle');
                const isEnabled = detector.id === 'baseline_threshold' ? true : (toggle ? toggle.checked : false);
                if (!isEnabled) return;
                
                const params = {};
                if (detector.params && detector.params.length > 0) {
                    detector.params.forEach(param => {
                        const input = item.querySelector(`input[data-param-key="${param.key}"]`);
                        if (input && input.value !== '') {
                            if (param.type === 'number') {
                                params[param.key] = parseFloat(input.value);
                            } else {
                                params[param.key] = input.value;
                            }
                        }
                    });
                }
                
                enabled.push({
                    id: detector.id,
                    label: detector.label,
                    type: detector.type,
                    params: params
                });
            });
            return enabled;
        }
        
        function updateDetectorSelects() {
            const enabled = getEnabledDetectors();
            const defaultSelect = document.getElementById('defaultDetectorSelect');
            const compareContainer = document.getElementById('compareDetectorsContainer');
            if (!defaultSelect || !compareContainer) return;
            
            defaultSelect.innerHTML = '';
            enabled.forEach(detector => {
                const option = document.createElement('option');
                option.value = detector.id;
                option.textContent = detector.label;
                defaultSelect.appendChild(option);
            });
            
            if (enabled.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = '-- –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –¥–µ—Ç–µ–∫—Ç–æ—Ä–æ–≤ --';
                defaultSelect.appendChild(option);
            }
            
            if (!enabled.some(detector => detector.id === defaultSelect.value) && enabled.length > 0) {
                defaultSelect.value = enabled[0].id;
            }
            
            compareContainer.innerHTML = '';
            enabled.forEach(detector => {
                const wrapper = document.createElement('label');
                wrapper.className = 'checkbox-group';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = detector.id;
                checkbox.className = 'compare-detector-checkbox';
                const span = document.createElement('span');
                span.textContent = detector.label;
                wrapper.appendChild(checkbox);
                wrapper.appendChild(span);
                compareContainer.appendChild(wrapper);
            });
        }
        
        function collectDetectorsConfig() {
            const enabled = getEnabledDetectors();
            const detectorsConfig = {};
            enabled.forEach(detector => {
                const config = {
                    type: detector.type,
                    label: detector.label,
                    enabled: true
                };
                if (detector.params && Object.keys(detector.params).length > 0) {
                    config.params = detector.params;
                }
                detectorsConfig[detector.id] = config;
            });
            
            const defaultSelect = document.getElementById('defaultDetectorSelect');
            const defaultDetector = defaultSelect && defaultSelect.value ? defaultSelect.value : (enabled[0] ? enabled[0].id : 'baseline_threshold');
            
            const compareDetectors = [];
            const compareCheckboxes = document.querySelectorAll('.compare-detector-checkbox');
            compareCheckboxes.forEach(checkbox => {
                if (checkbox.checked && checkbox.value !== defaultDetector) {
                    compareDetectors.push(checkbox.value);
                }
            });
            
            return {
                detectors: detectorsConfig,
                defaultDetector,
                compareDetectors
            };
        }
        
        function applyDetectorsFromConfig(eventsConfig) {
            const container = document.getElementById('detectorsContainer');
            if (!container) return;
            
            const toggles = container.querySelectorAll('.detector-toggle');
            toggles.forEach(toggle => {
                if (!toggle.disabled) {
                    toggle.checked = false;
                }
            });
            
            let detectorsMap = {};
            if (eventsConfig && eventsConfig.detectors) {
                if (Array.isArray(eventsConfig.detectors)) {
                    eventsConfig.detectors.forEach(det => {
                        if (det && (det.id || det.name)) {
                            detectorsMap[det.id || det.name] = det;
                        }
                    });
                } else {
                    detectorsMap = eventsConfig.detectors;
                }
            }
            
            AVAILABLE_DETECTORS.forEach(detector => {
                const item = container.querySelector(`.detector-item[data-detector-id="${detector.id}"]`);
                if (!item) return;
                const toggle = item.querySelector('.detector-toggle');
                const detConfig = detectorsMap ? detectorsMap[detector.id] : undefined;
                if (toggle && !toggle.disabled) {
                    toggle.checked = !!detConfig && detConfig.enabled !== false;
                }
                if (detector.id === 'baseline_threshold' && toggle) {
                    toggle.checked = true;
                }
                if (detector.params && detector.params.length > 0) {
                    detector.params.forEach(param => {
                        const input = item.querySelector(`input[data-param-key="${param.key}"]`);
                        if (!input) return;
                        if (detConfig && detConfig.params && detConfig.params[param.key] !== undefined) {
                            input.value = detConfig.params[param.key];
                        } else if (param.default !== undefined) {
                            input.value = param.default;
                        } else {
                            input.value = '';
                        }
                    });
                }
            });
            
            updateDetectorSelects();
            
            if (eventsConfig && eventsConfig.default_detector) {
                const defaultSelect = document.getElementById('defaultDetectorSelect');
                if (defaultSelect) {
                    defaultSelect.value = eventsConfig.default_detector;
                    if (!defaultSelect.value && defaultSelect.options.length > 0) {
                        defaultSelect.value = defaultSelect.options[0].value;
                    }
                }
            }
            
            if (eventsConfig && eventsConfig.compare_detectors) {
                const compareSet = new Set(eventsConfig.compare_detectors);
                const compareCheckboxes = document.querySelectorAll('.compare-detector-checkbox');
                compareCheckboxes.forEach(checkbox => {
                    checkbox.checked = compareSet.has(checkbox.value);
                });
            }
        }
        
        renderDetectorControls();
        
        function generateConfig() {
            const config = {
                job: {
                    name: document.getElementById('jobName').value || 'my_analysis',
                    description: document.getElementById('jobDescription').value || ''
                },
                data_source: {
                    ydb: {
                        query: document.getElementById('ydbQuery').value || ''
                    }
                },
                context_fields: getArrayValues('contextFields'),
                metric_fields: getArrayValues('metricFields'),
                timestamp_field: document.getElementById('timestampField').value || 'ts',
                analytics: {
                    baseline_method: document.getElementById('baselineMethod').value,
                    window_size: parseInt(document.getElementById('windowSize').value) || 7,
                    sensitivity: parseFloat(document.getElementById('sensitivity').value) || 2.0,
                    min_absolute_change: parseInt(document.getElementById('minAbsoluteChange').value) || 5,
                    min_relative_change: parseFloat(document.getElementById('minRelativeChange').value) || 0.05,
                    hysteresis_points: parseInt(document.getElementById('hysteresisPoints').value) || 2,
                    adaptive_threshold: document.getElementById('adaptiveThreshold').checked,
                    min_data_points: parseInt(document.getElementById('minDataPoints').value) || 3
                },
                metric_direction: {
                    default: document.getElementById('metricDirectionDefault').value
                },
                events: {
                    detect: []
                },
                thresholds: {
                    keep_history: document.getElementById('keepHistory').checked
                },
                output: {
                    write_to_ydb: document.getElementById('writeToYdb').checked,
                    log_to_console: document.getElementById('logToConsole').checked,
                    dry_run: document.getElementById('dryRun').checked
                },
                runtime: {
                    timezone: document.getElementById('timezone').value || 'UTC',
                    max_runtime_minutes: parseInt(document.getElementById('maxRuntime').value) || 15
                }
            };
            
            // Add aggregate_by if specified
            const aggregateBy = document.getElementById('aggregateBy').value.trim();
            if (aggregateBy) {
                config.data_source.aggregate_by = aggregateBy;
            }
            
            // Add metric directions
            const metricDirs = getMetricDirections();
            Object.assign(config.metric_direction, metricDirs);
            
            // Add events - ensure at least one is selected
            const detectDegradation = document.getElementById('detectDegradation');
            const detectImprovement = document.getElementById('detectImprovement');
            const detectThresholdShift = document.getElementById('detectThresholdShift');
            
            if (detectDegradation && detectDegradation.checked) {
                config.events.detect.push('degradation_start');
            }
            if (detectImprovement && detectImprovement.checked) {
                config.events.detect.push('improvement_start');
            }
            if (detectThresholdShift && detectThresholdShift.checked) {
                config.events.detect.push('threshold_shift');
            }
            
            // If no events selected, add default
            if (config.events.detect.length === 0) {
                config.events.detect.push('degradation_start');
            }
            
              const detectorsState = collectDetectorsConfig();
              if (detectorsState.detectors && Object.keys(detectorsState.detectors).length > 0) {
                  config.events.detectors = detectorsState.detectors;
                  if (detectorsState.defaultDetector) {
                      config.events.default_detector = detectorsState.defaultDetector;
                  }
                  if (detectorsState.compareDetectors && detectorsState.compareDetectors.length > 0) {
                      config.events.compare_detectors = detectorsState.compareDetectors;
                  }
              }
              
            // Add output tables if specified
            const eventsTable = document.getElementById('eventsOutputTable').value.trim();
            if (eventsTable) {
                config.events.output_table = eventsTable;
            }
            
            const thresholdsTable = document.getElementById('thresholdsOutputTable').value.trim();
            if (thresholdsTable) {
                config.thresholds.output_table = thresholdsTable;
            }
            
            // Add min_event_duration_minutes
            const minDuration = parseInt(document.getElementById('minEventDuration').value);
            if (minDuration) {
                config.events.min_event_duration_minutes = minDuration;
            }
            
            // Add context tracking if enabled
            if (document.getElementById('trackNewContexts').checked || document.getElementById('trackDisappearedContexts').checked) {
                config.context_tracking = {
                    track_new_contexts: document.getElementById('trackNewContexts').checked,
                    track_disappeared_contexts: document.getElementById('trackDisappearedContexts').checked,
                    context_change_rules: {}
                };
                
                const newMetric = document.getElementById('newContextMetric').value.trim();
                if (newMetric && document.getElementById('trackNewContexts').checked) {
                    config.context_tracking.context_change_rules.new_context_metrics = {
                        [newMetric]: {
                            event_type: document.getElementById('newContextEventType').value,
                            severity: 'high',
                            baseline_before: 0.0
                        }
                    };
                }
                
                const disappearedMetric = document.getElementById('disappearedContextMetric').value.trim();
                if (disappearedMetric && document.getElementById('trackDisappearedContexts').checked) {
                    config.context_tracking.context_change_rules.disappeared_context_metrics = {
                        [disappearedMetric]: {
                            event_type: 'improvement_start',
                            severity: 'medium',
                            baseline_after: 0.0,
                            min_absence_points: parseInt(document.getElementById('minAbsencePoints').value) || 3,
                            absence_type: 'consecutive',
                            min_historical_points: 2
                        }
                    };
                }
            }
            
            // Convert to YAML
            const yaml = toYAML(config);
            document.getElementById('preview').textContent = yaml;
        }
        
        function toYAML(obj, indent = 0, parentKey = null) {
            const spaces = '  '.repeat(indent);
            let yaml = '';
            
            // Fields that should be inline arrays
            const inlineArrayFields = ['context_fields', 'metric_fields'];
            
            // Fields that should use block literal (|) for multiline strings
            const multilineFields = ['query'];
            
            if (Array.isArray(obj)) {
                if (obj.length === 0) return '[]';
                // Check if parent key is in inline array fields
                if (parentKey && inlineArrayFields.includes(parentKey)) {
                    // Generate inline array format
                    const items = obj.map(item => formatValue(item)).join(', ');
                    return '[' + items + ']';
                }
                // Otherwise use multiline format
                obj.forEach(item => {
                    if (typeof item === 'object' && item !== null) {
                        yaml += spaces + '-\n' + toYAML(item, indent + 1);
                    } else {
                        yaml += spaces + '- ' + formatValue(item) + '\n';
                    }
                });
            } else if (typeof obj === 'object' && obj !== null) {
                Object.entries(obj).forEach(([key, value]) => {
                    if (value === null || value === undefined) {
                        return;
                    }
                    
                    if (Array.isArray(value)) {
                        if (value.length === 0) {
                            yaml += spaces + key + ': []\n';
                        } else if (inlineArrayFields.includes(key)) {
                            // Use inline format for specific fields
                            const items = value.map(item => formatValue(item)).join(', ');
                            yaml += spaces + key + ': [' + items + ']\n';
                        } else {
                            // Use multiline format for other arrays
                            yaml += spaces + key + ':\n';
                            value.forEach(item => {
                                if (typeof item === 'object' && item !== null) {
                                    yaml += spaces + '  -\n' + toYAML(item, indent + 2);
                                } else {
                                    yaml += spaces + '  - ' + formatValue(item) + '\n';
                                }
                            });
                        }
                    } else if (typeof value === 'object' && value !== null) {
                        yaml += spaces + key + ':\n';
                        yaml += toYAML(value, indent + 1, key);
                    } else {
                        // Check if this is a multiline string field
                        if (typeof value === 'string' && multilineFields.includes(key) && value.includes('\n')) {
                            // Use block literal (|) for multiline strings
                            const lines = value.split('\n');
                            yaml += spaces + key + ': |\n';
                            lines.forEach(line => {
                                yaml += spaces + '  ' + line + '\n';
                            });
                        } else {
                            yaml += spaces + key + ': ' + formatValue(value) + '\n';
                        }
                    }
                });
            } else {
                yaml += spaces + formatValue(obj) + '\n';
            }
            
            return yaml;
        }
        
        function formatValue(value) {
            if (typeof value === 'string') {
                // Check if string needs quoting
                if (value.includes(':') || value.includes('#') || value.includes('\n') || 
                    value.includes('&') || value.includes('*') || value.includes('!') ||
                    value.includes('|') || value.includes('>') || value.includes("'") ||
                    value.includes('"') || value.includes('[') || value.includes(']') ||
                    value.includes('{') || value.includes('}') || value.includes(',') ||
                    value.trim() !== value || /^\d/.test(value)) {
                    // Escape quotes and use double quotes
                    return '"' + value.replace(/"/g, '\\"') + '"';
                }
                return value;
            } else if (typeof value === 'boolean') {
                return value ? 'true' : 'false';
            } else if (typeof value === 'number') {
                return value.toString();
            }
            return String(value);
        }
        
        function copyToClipboard(event) {
            const preview = document.getElementById('preview');
            const text = preview.textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                const btn = event ? event.target : document.querySelector('.btn-copy');
                const originalText = btn.textContent;
                btn.textContent = '‚úì –°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!';
                btn.style.background = '#4CAF50';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '#2196F3';
                }, 2000);
            }).catch(err => {
                alert('–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è: ' + err);
            });
        }
        
        // API functions
        const API_BASE = window.location.origin;
        
        async function saveConfig() {
            const filename = document.getElementById('configFileName').value.trim();
            if (!filename) {
                alert('–£–∫–∞–∂–∏—Ç–µ –∏–º—è —Ñ–∞–π–ª–∞');
                return;
            }
            
            const yaml = document.getElementById('preview').textContent;
            if (!yaml || yaml.includes('–ó–∞–ø–æ–ª–Ω–∏—Ç–µ —Ñ–æ—Ä–º—É')) {
                alert('–°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ –∫–æ–Ω—Ñ–∏–≥');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/api/save-config`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        filename: filename,
                        content: yaml
                    })
                });
                
                const data = await response.json();
                if (response.ok) {
                    alert(`–ö–æ–Ω—Ñ–∏–≥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω: ${data.path}`);
                    document.getElementById('configFileName').value = '';
                } else {
                    alert(`–û—à–∏–±–∫–∞: ${data.error}`);
                }
            } catch (error) {
                alert(`–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏: ${error.message}`);
            }
        }
        
        async function runAnalytics() {
            const filename = document.getElementById('configFileName').value.trim();
            const dryRun = document.getElementById('dryRunCheck').checked;
            const eventDeepnessInput = document.getElementById('eventDeepnessInput');
            const eventDeepness = eventDeepnessInput ? eventDeepnessInput.value.trim() : '';
            const statusDiv = document.getElementById('runStatus');
            
            // Get current config
            const yaml = document.getElementById('preview').textContent;
            if (!yaml || yaml.includes('–ó–∞–ø–æ–ª–Ω–∏—Ç–µ —Ñ–æ—Ä–º—É')) {
                alert('–°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ –∫–æ–Ω—Ñ–∏–≥');
                return;
            }
            
            // Save config first if filename provided
            let configPath = null;
            if (filename) {
                try {
                    const saveResponse = await fetch(`${API_BASE}/api/save-config`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            filename: filename,
                            content: yaml
                        })
                    });
                    
                    const saveData = await saveResponse.json();
                    if (!saveResponse.ok) {
                        alert(`–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∫–æ–Ω—Ñ–∏–≥–∞: ${saveData.error}`);
                        return;
                    }
                    configPath = saveData.path;
                } catch (error) {
                    alert(`–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏: ${error.message}`);
                    return;
                }
            } else {
                // Use temporary file
                const tempFilename = `temp_${Date.now()}.yaml`;
                try {
                    const saveResponse = await fetch(`${API_BASE}/api/save-config`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            filename: tempFilename,
                            content: yaml
                        })
                    });
                    
                    const saveData = await saveResponse.json();
                    if (!saveResponse.ok) {
                        alert(`–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∫–æ–Ω—Ñ–∏–≥–∞: ${saveData.error}`);
                        return;
                    }
                    configPath = saveData.path;
                } catch (error) {
                    alert(`–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏: ${error.message}`);
                    return;
                }
            }
            
            // Show status
            statusDiv.style.display = 'block';
            statusDiv.style.background = '#fff3cd';
            statusDiv.style.color = '#856404';
            statusDiv.textContent = '‚è≥ –ó–∞–ø—É—Å–∫ –∞–Ω–∞–ª–∏—Ç–∏–∫–∏...';
            
            try {
                const payload = {
                    config_path: configPath,
                    dry_run: dryRun
                };
                if (eventDeepness) {
                    payload.event_deepness = eventDeepness;
                }
                
                const response = await fetch(`${API_BASE}/api/run`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });
                
                const data = await response.json();
                if (response.ok && data.success) {
                    statusDiv.style.background = '#d4edda';
                    statusDiv.style.color = '#155724';
                    statusDiv.innerHTML = `
                        <strong>‚úÖ –ê–Ω–∞–ª–∏—Ç–∏–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ!</strong><br>
                        <pre style="margin-top: 10px; font-size: 12px; overflow-x: auto;">${data.output}</pre>
                    `;
                    
                    // Reload reports
                    setTimeout(loadReports, 1000);
                } else {
                    statusDiv.style.background = '#f8d7da';
                    statusDiv.style.color = '#721c24';
                    statusDiv.innerHTML = `
                        <strong>‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–∏</strong><br>
                        <pre style="margin-top: 10px; font-size: 12px; overflow-x: auto;">${data.error || data.output || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'}</pre>
                    `;
                }
            } catch (error) {
                statusDiv.style.background = '#f8d7da';
                statusDiv.style.color = '#721c24';
                statusDiv.innerHTML = `<strong>‚ùå –û—à–∏–±–∫–∞:</strong> ${error.message}`;
            }
        }
        
        async function loadReports() {
            const reportsList = document.getElementById('reportsList');
            reportsList.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">–ó–∞–≥—Ä—É–∑–∫–∞...</p>';
            
            try {
                const response = await fetch(`${API_BASE}/api/reports`);
                const data = await response.json();
                
                if (data.reports && data.reports.length > 0) {
                    let html = '<div style="display: flex; flex-direction: column; gap: 10px;">';
                    data.reports.forEach(report => {
                        const date = new Date(report.modified);
                        const dateStr = date.toLocaleString('ru-RU');
                        
                        // Extract job name from filename (format: {job_name}_summary_{timestamp}.html)
                        const filename = report.name;
                        const jobNameMatch = filename.match(/^(.+?)_summary_/);
                        const jobName = jobNameMatch ? jobNameMatch[1] : filename.replace('_summary_', ' ').replace('.html', '');
                        
                        html += `
                            <div style="padding: 12px; background: white; border: 1px solid #ddd; border-radius: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div style="flex: 1;">
                                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                                            <span style="font-size: 18px;">üìä</span>
                                            <strong style="font-size: 14px; color: #333;">${jobName}</strong>
                                            <span style="background: #4CAF50; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: 500;">Summary</span>
                                        </div>
                                        <small style="color: #666; font-size: 12px;">${dateStr} ‚Ä¢ ${(report.size / 1024).toFixed(1)} KB</small>
                                    </div>
                                    <a href="${API_BASE}${report.path}" target="_blank" style="padding: 10px 20px; background: #2196F3; color: white; text-decoration: none; border-radius: 6px; font-size: 14px; font-weight: 500; white-space: nowrap; margin-left: 15px;">
                                        üìÑ –û—Ç–∫—Ä—ã—Ç—å –æ—Ç—á–µ—Ç
                                    </a>
                                </div>
                            </div>
                        `;
                    });
                    html += '</div>';
                    reportsList.innerHTML = html;
                } else {
                    reportsList.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">–û—Ç—á–µ—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –ó–∞–ø—É—Å—Ç–∏—Ç–µ –∞–Ω–∞–ª–∏—Ç–∏–∫—É –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç—á–µ—Ç–æ–≤.</p>';
                }
            } catch (error) {
                reportsList.innerHTML = `<p style="color: #d32f2f; text-align: center; padding: 20px;">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: ${error.message}</p>`;
            }
        }
        
        // Initialize with default values
        window.addEventListener('DOMContentLoaded', function() {
            const queryField = document.getElementById('ydbQuery');
            if (queryField) {
                queryField.value = 'SELECT\n  timestamp as ts,\n  cluster,\n  metric_value,\n  \'metric_name\' as metric_name\nFROM `your_table`\nWHERE timestamp >= CurrentUtcTimestamp() - 30 * Interval("P1D")';
            }
            
            // Set default context field value if exists
            const contextFieldsContainer = document.getElementById('contextFields');
            if (contextFieldsContainer) {
                const firstInput = contextFieldsContainer.querySelector('.array-input:first-child input');
                if (firstInput) {
                    firstInput.value = 'cluster';
                }
            }
            
            // Generate initial config
            setTimeout(function() {
                if (typeof generateConfig === 'function') {
                    generateConfig();
                }
            }, 100);
            
            // Load reports on startup
            loadReports();
        });
    </script>
</body>
</html>

